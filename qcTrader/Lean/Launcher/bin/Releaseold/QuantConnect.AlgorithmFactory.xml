<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QuantConnect.AlgorithmFactory</name>
    </assembly>
    <members>
        <member name="T:QuantConnect.AlgorithmFactory.DebuggerHelper">
            <summary>
            Helper class used to start a new debugging session
            </summary>
        </member>
        <member name="T:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod">
            <summary>
            The different implemented debugging methods
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod.LocalCmdline">
            <summary>
            Local debugging through cmdline.
            <see cref="F:QuantConnect.Language.Python"/> will use built in 'pdb'
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod.VisualStudio">
            <summary>
            Visual studio local debugging.
            <see cref="F:QuantConnect.Language.Python"/> will use 'Python Tools for Visual Studio',
            attach manually selecting `Python` code type.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod.PTVSD">
            <summary>
             Python Tool for Visual Studio Debugger for remote python debugging.
            <see cref="F:QuantConnect.Language.Python"/>. Deprecated, routes to DebugPy which
            is it's replacement. Used in the same way.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod.DebugPy">
            <summary>
             DebugPy - a debugger for Python.
            <see cref="F:QuantConnect.Language.Python"/> can use  `Python Extension` in VS Code
            or attach to Python in Visual Studio
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.DebuggerHelper.DebuggingMethod.PyCharm">
            <summary>
             PyCharm PyDev Debugger for remote python debugging.
            <see cref="F:QuantConnect.Language.Python"/> will use 'Python Debug Server' in PyCharm
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.DebuggerHelper.Initialize(QuantConnect.Language,System.Action@)">
            <summary>
            Will start a new debugging session
            </summary>
            <param name="language">The algorithms programming language</param>
            <param name="workersInitializationCallback">Optionally, the debugging method will set an action which the data stack workers should execute
            so we can debug code executed by them, this is specially important for python.</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.DebuggerHelper.DebugpyThreadInitialization">
            <summary>
            For each thread we need to create it's python state, we do this by taking the GIL and we later release it by calling 'BeginAllowThreads'
            but we do not dispose of it. If we did, the state of the debugpy calls we do here are lost. So we keep a reference of the GIL we've
            created so it's not picked up the C# garbage collector and disposed off, which would clear the py thread state.
            </summary>
        </member>
        <member name="T:QuantConnect.AlgorithmFactory.Loader">
            <summary>
            Loader creates and manages the memory and exception space of the algorithm, ensuring if it explodes the Lean Engine is intact.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Loader.appDomain">
            <summary>
            Memory space of the user algorithm
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.Loader.AlgorithmInterfaceType">
            <summary>
            The algorithm's interface type that we'll be trying to load
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.Loader.AlgorithmBaseTypeFullName">
            <summary>
            The full type name of QCAlgorithm, this is so we don't pick him up when querying for types
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmFactory.Loader.FrameworkBaseTypeFullName">
            <summary>
            The full type name of QCAlgorithmFramework, this is so we don't pick him up when querying for types
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.#ctor">
            <summary>
            Creates a new loader with a 10 second maximum load time that forces exactly one derived type to be found
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.#ctor(System.Boolean,QuantConnect.Language,System.TimeSpan,System.Func{System.Collections.Generic.List{System.String},System.String},QuantConnect.Util.WorkerThread)">
             <summary>
             Creates a new loader with the specified configuration
             </summary>
             <param name="debugging">True if we are debugging</param>
             <param name="language">Which language are we trying to load</param>
             <param name="loaderTimeLimit">
             Used to limit how long it takes to create a new instance
             </param>
             <param name="multipleTypeNameResolverFunction">
             Used to resolve multiple type names found in assembly to a single type name, if null, defaults to names => names.SingleOrDefault()
            
             When we search an assembly for derived types of IAlgorithm, sometimes the assembly will contain multiple matching types. This is the case
             for the QuantConnect.Algorithm assembly in this solution.  In order to pick the correct type, consumers must specify how to pick the type,
             that's what this function does, it picks the correct type from the list of types found within the assembly.
             </param>
             <param name="workerThread">The worker thread instance the loader should use</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.TryCreateAlgorithmInstance(System.String,QuantConnect.Interfaces.IAlgorithm@,System.String@)">
            <summary>
            Creates a new instance of the specified class in the library, safely.
            </summary>
            <param name="assemblyPath">Location of the DLL</param>
            <param name="algorithmInstance">Output algorithm instance</param>
            <param name="errorMessage">Output error message on failure</param>
            <returns>Bool true on successfully loading the class.</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.TryCreatePythonAlgorithm(System.String,QuantConnect.Interfaces.IAlgorithm@,System.String@)">
            <summary>
            Create a new instance of a python algorithm
            </summary>
            <param name="assemblyPath"></param>
            <param name="algorithmInstance"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.TryCreateILAlgorithm(System.String,QuantConnect.Interfaces.IAlgorithm@,System.String@)">
            <summary>
            Create a generic IL algorithm
            </summary>
            <param name="assemblyPath"></param>
            <param name="algorithmInstance"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.GetExtendedTypeNames(System.Reflection.Assembly)">
            <summary>
            Get a list of all the matching type names in this DLL assembly:
            </summary>
            <param name="assembly">Assembly dll we're loading.</param>
            <returns>String list of types available.</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.TryCreateAlgorithmInstanceWithIsolator(System.String,System.Int32,QuantConnect.Interfaces.IAlgorithm@,System.String@)">
            <summary>
            Creates a new instance of the class in the library, safely.
            </summary>
            <param name="assemblyPath">Location of the DLL</param>
            <param name="ramLimit">Limit of the RAM for this process</param>
            <param name="algorithmInstance">Output algorithm instance</param>
            <param name="errorMessage">Output error message on failure</param>
            <returns>bool success</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Loader.Unload">
            <summary>
            Unload this factory's appDomain.
            </summary>
            <remarks>Not used in lean engine. Running the library in an app domain is 10x slower.</remarks>
            <seealso cref="!:AppDomain.CreateDomain(string, Evidence, string, string, bool, AppDomainInitializer, string[])"/>
        </member>
        <member name="T:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper">
            <summary>
            Creates and wraps the algorithm written in python.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.IsOnEndOfDayImplemented">
            <summary>
            True if the underlying python algorithm implements "OnEndOfDay"
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.IsOnEndOfDaySymbolImplemented">
            <summary>
            True if the underlying python algorithm implements "OnEndOfDay(symbol)"
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.#ctor(System.String)">
            <summary>
            <see cref = "T:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper"/> constructor.
            Creates and wraps the algorithm written in python.
            </summary>
            <param name="moduleName">Name of the module that can be found in the PYTHONPATH</param>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AlgorithmId">
            <summary>
            AlgorithmId for the backtest
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Benchmark">
            <summary>
            Gets the function used to define the benchmark. This function will return
            the value of the benchmark at a requested date/time
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.BrokerageMessageHandler">
            <summary>
            Gets the brokerage message handler used to decide what to do
            with each message sent from the brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.BrokerageModel">
            <summary>
            Gets the brokerage model used to emulate a real brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.BrokerageName">
            <summary>
            Gets the brokerage name.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.RiskFreeInterestRateModel">
            <summary>
            Gets the risk free interest rate model used to get the interest rates
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.DebugMessages">
            <summary>
            Debug messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.EndDate">
            <summary>
            Get Requested Backtest End Date
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.ErrorMessages">
            <summary>
            Error messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.HistoryProvider">
            <summary>
            Gets or sets the history provider for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.IsWarmingUp">
            <summary>
            Gets whether or not this algorithm is still warming up
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.LiveMode">
            <summary>
            Algorithm is running on a live server.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AlgorithmMode">
            <summary>
            Algorithm running mode.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.DeploymentTarget">
            <summary>
            Deployment target, either local or cloud.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.LogMessages">
            <summary>
            Log messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Name">
            <summary>
            Public name for the algorithm.
            </summary>
            <remarks>Not currently used but preserved for API integrity</remarks>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Tags">
            <summary>
            A list of tags associated with the algorithm or the backtest, useful for categorization
            </summary>
        </member>
        <member name="E:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.NameUpdated">
            <summary>
            Event fired algorithm's name is changed
            </summary>
        </member>
        <member name="E:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.TagsUpdated">
            <summary>
            Event fired when the tag collection is updated
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Notify">
            <summary>
            Notification manager for storing and processing live event messages
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Portfolio">
            <summary>
            Security portfolio management class provides wrapper and helper methods for the Security.Holdings class such as
            IsLong, IsShort, TotalProfit
            </summary>
            <remarks>Portfolio is a wrapper and helper class encapsulating the Securities[].Holdings objects</remarks>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.RunTimeError">
            <summary>
            Gets the run time error from the algorithm, or null if none was encountered.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.RuntimeStatistics">
            <summary>
            Customizable dynamic statistics displayed during live trading:
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Schedule">
            <summary>
            Gets schedule manager for adding/removing scheduled events
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Securities">
            <summary>
            Security object collection class stores an array of objects representing representing each security/asset
            we have a subscription for.
            </summary>
            <remarks>It is an IDictionary implementation and can be indexed by symbol</remarks>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SecurityInitializer">
            <summary>
            Gets an instance that is to be used to initialize newly created securities.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.TradeBuilder">
            <summary>
            Gets the Trade Builder to generate trades from executions
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Settings">
            <summary>
            Gets the user settings for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OptionChainProvider">
            <summary>
            Gets the option chain provider, used to get the list of option contracts for an underlying symbol
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.FutureChainProvider">
            <summary>
            Gets the future chain provider, used to get the list of future contracts for an underlying symbol
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.ObjectStore">
            <summary>
            Gets the object store, used for persistence
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.CurrentSlice">
            <summary>
            Returns the current Slice object
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.StartDate">
            <summary>
            Algorithm start date for backtesting, set by the SetStartDate methods.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Status">
            <summary>
            Gets or sets the current status of the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetStatus(QuantConnect.AlgorithmStatus)">
            <summary>
            Set the state of a live deployment
            </summary>
            <param name="status">Live deployment status</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetAvailableDataTypes(System.Collections.Generic.Dictionary{QuantConnect.SecurityType,System.Collections.Generic.List{QuantConnect.TickType}})">
            <summary>
            Set the available <see cref="T:QuantConnect.TickType"/> supported by each <see cref="T:QuantConnect.SecurityType"/> in <see cref="T:QuantConnect.Securities.SecurityManager"/>
            </summary>
            <param name="availableDataTypes">>The different <see cref="T:QuantConnect.TickType"/> each <see cref="T:QuantConnect.Securities.Security"/> supports</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetOptionChainProvider(QuantConnect.Interfaces.IOptionChainProvider)">
            <summary>
            Sets the option chain provider, used to get the list of option contracts for an underlying symbol
            </summary>
            <param name="optionChainProvider">The option chain provider</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetFutureChainProvider(QuantConnect.Interfaces.IFutureChainProvider)">
            <summary>
            Sets the future chain provider, used to get the list of future contracts for an underlying symbol
            </summary>
            <param name="futureChainProvider">The future chain provider</param>
        </member>
        <member name="E:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.InsightsGenerated">
            <summary>
            Event fired when an algorithm generates a insight
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.TimeKeeper">
            <summary>
            Gets the time keeper instance
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SubscriptionManager">
            <summary>
            Data subscription manager controls the information and subscriptions the algorithms recieves.
            Subscription configurations can be added through the Subscription Manager.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.ProjectId">
            <summary>
            The project id associated with this algorithm if any
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Time">
            <summary>
            Current date/time in the algorithm's local time zone
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.TimeZone">
            <summary>
            Gets the time zone of the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Transactions">
            <summary>
            Security transaction manager class controls the store and processing of orders.
            </summary>
            <remarks>The orders and their associated events are accessible here. When a new OrderEvent is recieved the algorithm portfolio is updated.</remarks>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.UniverseManager">
            <summary>
            Gets the collection of universes for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.UniverseSettings">
            <summary>
            Gets the subscription settings to be used when adding securities via universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.UtcTime">
            <summary>
            Current date/time in UTC.
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AccountCurrency">
            <summary>
            Gets the account currency
            </summary>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Insights">
            <summary>
            Gets the insight manager
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetStatisticsService(QuantConnect.Statistics.IStatisticsService)">
            <summary>
            Sets the statistics service instance to be used by the algorithm
            </summary>
            <param name="statisticsService">The statistics service instance</param>
        </member>
        <member name="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Statistics">
            <summary>
            The current statistics for the running algorithm.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddSecurity(QuantConnect.SecurityType,System.String,System.Nullable{QuantConnect.Resolution},System.String,System.Boolean,System.Decimal,System.Boolean,System.Nullable{QuantConnect.DataMappingMode},System.Nullable{QuantConnect.DataNormalizationMode})">
            <summary>
            Set a required SecurityType-symbol and resolution for algorithm
            </summary>
            <param name="securityType">SecurityType Enum: Equity, Commodity, FOREX or Future</param>
            <param name="symbol">Symbol Representation of the MarketType, e.g. AAPL</param>
            <param name="resolution">The <see cref="T:QuantConnect.Resolution"/> of market data, Tick, Second, Minute, Hour, or Daily.</param>
            <param name="market">The market the requested security belongs to, such as 'usa' or 'fxcm'</param>
            <param name="fillForward">If true, returns the last available data even if none in that timeslice.</param>
            <param name="leverage">leverage for this security</param>
            <param name="extendedMarketHours">Use extended market hours data</param>
            <param name="dataMappingMode">The contract mapping mode to use for the security</param>
            <param name="dataNormalizationMode">The price scaling mode to use for the security</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddSecurity(QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Decimal,System.Boolean,System.Nullable{QuantConnect.DataMappingMode},System.Nullable{QuantConnect.DataNormalizationMode},System.Int32)">
            <summary>
            Set a required SecurityType-symbol and resolution for algorithm
            </summary>
            <param name="symbol">The security Symbol</param>
            <param name="resolution">Resolution of the MarketType required: MarketData, Second or Minute</param>
            <param name="fillForward">If true, returns the last available data even if none in that timeslice.</param>
            <param name="leverage">leverage for this security</param>
            <param name="extendedMarketHours">Use extended market hours data</param>
            <param name="dataMappingMode">The contract mapping mode to use for the security</param>
            <param name="dataNormalizationMode">The price scaling mode to use for the security</param>
            <param name="contractDepthOffset">The continuous contract desired offset from the current front month.
            For example, 0 (default) will use the front month, 1 will use the back month contract</param>
            <returns>The new Security that was added to the algorithm</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddFutureContract(QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Decimal,System.Boolean)">
            <summary>
            Creates and adds a new single <see cref="T:QuantConnect.Securities.Future.Future"/> contract to the algorithm
            </summary>
            <param name="symbol">The futures contract symbol</param>
            <param name="resolution">The <see cref="T:QuantConnect.Resolution"/> of market data, Tick, Second, Minute, Hour, or Daily. Default is <see cref="F:QuantConnect.Resolution.Minute"/></param>
            <param name="fillForward">If true, returns the last available data even if none in that timeslice. Default is <value>true</value></param>
            <param name="leverage">The requested leverage for this equity. Default is set by <see cref="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SecurityInitializer"/></param>
            <param name="extendedMarketHours">Use extended market hours data</param>
            <returns>The new <see cref="T:QuantConnect.Securities.Future.Future"/> security</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddOptionContract(QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Decimal,System.Boolean)">
            <summary>
            Creates and adds a new single <see cref="T:QuantConnect.Securities.Option.Option"/> contract to the algorithm
            </summary>
            <param name="symbol">The option contract symbol</param>
            <param name="resolution">The <see cref="T:QuantConnect.Resolution"/> of market data, Tick, Second, Minute, Hour, or Daily. Default is <see cref="F:QuantConnect.Resolution.Minute"/></param>
            <param name="fillForward">If true, returns the last available data even if none in that timeslice. Default is <value>true</value></param>
            <param name="leverage">The requested leverage for this equity. Default is set by <see cref="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SecurityInitializer"/></param>
            <param name="extendedMarketHours">Use extended market hours data</param>
            <returns>The new <see cref="T:QuantConnect.Securities.Option.Option"/> security</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnEndOfTimeStep">
            <summary>
            Invoked at the end of every time step. This allows the algorithm
            to process events before advancing to the next time step.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Debug(System.String)">
            <summary>
            Send debug message
            </summary>
            <param name="message">String message</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Error(System.String)">
            <summary>
            Send an error message for the algorithm
            </summary>
            <param name="message">String message</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddChart(QuantConnect.Chart)">
            <summary>
            Add a Chart object to algorithm collection
            </summary>
            <param name="chart">Chart object to add to collection.</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetChartUpdates(System.Boolean)">
            <summary>
            Get the chart updates since the last request:
            </summary>
            <param name="clearChartData"></param>
            <returns>List of Chart Updates</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetLocked">
            <summary>
            Gets whether or not this algorithm has been locked and fully initialized
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetParameters">
            <summary>
            Gets a read-only dictionary with all current parameters
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetParameter(System.String,System.String)">
            <summary>
            Gets the parameter with the specified name. If a parameter with the specified name does not exist,
            the given default value is returned if any, else null
            </summary>
            <param name="name">The name of the parameter to get</param>
            <param name="defaultValue">The default value to return</param>
            <returns>The value of the specified parameter, or defaultValue if not found or null if there's no default value</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetParameter(System.String,System.Int32)">
            <summary>
            Gets the parameter with the specified name parsed as an integer. If a parameter with the specified name does not exist,
            or the conversion is not possible, the given default value is returned
            </summary>
            <param name="name">The name of the parameter to get</param>
            <param name="defaultValue">The default value to return</param>
            <returns>The value of the specified parameter, or defaultValue if not found or null if there's no default value</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetParameter(System.String,System.Double)">
            <summary>
            Gets the parameter with the specified name parsed as a double. If a parameter with the specified name does not exist,
            or the conversion is not possible, the given default value is returned
            </summary>
            <param name="name">The name of the parameter to get</param>
            <param name="defaultValue">The default value to return</param>
            <returns>The value of the specified parameter, or defaultValue if not found or null if there's no default value</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetParameter(System.String,System.Decimal)">
            <summary>
            Gets the parameter with the specified name parsed as a decimal. If a parameter with the specified name does not exist,
            or the conversion is not possible, the given default value is returned
            </summary>
            <param name="name">The name of the parameter to get</param>
            <param name="defaultValue">The default value to return</param>
            <returns>The value of the specified parameter, or defaultValue if not found or null if there's no default value</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Initialize">
            <summary>
            Initialise the Algorithm and Prepare Required Data:
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Liquidate(QuantConnect.Symbol,System.Boolean,System.String,QuantConnect.Interfaces.IOrderProperties)">
            <summary>
            Liquidate your portfolio holdings
            </summary>
            <param name="symbol">Specific asset to liquidate, defaults to all</param>
            <param name="asynchronous">Flag to indicate if the symbols should be liquidated asynchronously</param>
            <param name="tag">Custom tag to know who is calling this</param>
            <param name="orderProperties">Order properties to use</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Log(System.String)">
            <summary>
            Save entry to the Log
            </summary>
            <param name="message">String message</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnBrokerageDisconnect">
            <summary>
            Brokerage disconnected event handler. This method is called when the brokerage connection is lost.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnBrokerageMessage(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Brokerage message event handler. This method is called for all types of brokerage messages.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnBrokerageReconnect">
            <summary>
            Brokerage reconnected event handler. This method is called when the brokerage connection is restored after a disconnection.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnData(QuantConnect.Data.Slice)">
            <summary>
            v3.0 Handler for all data types
            </summary>
            <param name="slice">The current slice of data</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnFrameworkData(QuantConnect.Data.Slice)">
            <summary>
            Used to send data updates to algorithm framework models
            </summary>
            <param name="slice">The current data slice</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnSplits(QuantConnect.Data.Market.Splits)">
            <summary>
            Event handler to be called when there's been a split event
            </summary>
            <param name="splits">The current time slice splits</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnDividends(QuantConnect.Data.Market.Dividends)">
            <summary>
            Event handler to be called when there's been a dividend event
            </summary>
            <param name="dividends">The current time slice dividends</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnDelistings(QuantConnect.Data.Market.Delistings)">
            <summary>
            Event handler to be called when there's been a delistings event
            </summary>
            <param name="delistings">The current time slice delistings</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnSymbolChangedEvents(QuantConnect.Data.Market.SymbolChangedEvents)">
            <summary>
            Event handler to be called when there's been a symbol changed event
            </summary>
            <param name="symbolsChanged">The current time slice symbol changed events</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnEndOfAlgorithm">
            <summary>
            Call this event at the end of the algorithm running.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnEndOfDay">
            <summary>
            End of a trading day event handler. This method is called at the end of the algorithm day (or multiple times if trading multiple assets).
            </summary>
            <remarks>Method is called 10 minutes before closing to allow user to close out position.</remarks>
            <remarks>Deprecated because different assets have different market close times,
            and because Python does not support two methods with the same name</remarks>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnEndOfDay(QuantConnect.Symbol)">
            <summary>
            End of a trading day event handler. This method is called at the end of the algorithm day (or multiple times if trading multiple assets).
            </summary>
            <remarks>
            This method is left for backwards compatibility and is invoked via <see cref="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnEndOfDay(QuantConnect.Symbol)"/>, if that method is
            override then this method will not be called without a called to base.OnEndOfDay(string)
            </remarks>
            <param name="symbol">Asset symbol for this end of day event. Forex and equities have different closing hours.</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnMarginCall(System.Collections.Generic.List{QuantConnect.Orders.SubmitOrderRequest})">
            <summary>
            Margin call event handler. This method is called right before the margin call orders are placed in the market.
            </summary>
            <param name="requests">The orders to be executed to bring this algorithm within margin limits</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnMarginCallWarning">
            <summary>
            Margin call warning event handler. This method is called when Portfolio.MarginRemaining is under 5% of your Portfolio.TotalPortfolioValue
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnOrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            EXPERTS ONLY:: [-!-Async Code-!-]
            New order event handler: on order status changes (filled, partially filled, cancelled etc).
            </summary>
            <param name="newEvent">Event information</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SubmitOrderRequest(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Will submit an order request to the algorithm
            </summary>
            <param name="request">The request to submit</param>
            <remarks>Will run order prechecks, which include making sure the algorithm is not warming up, security is added and has data among others</remarks>
            <returns>The order ticket</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnAssignmentOrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Option assignment event handler. On an option assignment event for short legs the resulting information is passed to this method.
            </summary>
            <param name="assignmentEvent">Option exercise event details containing details of the assignment</param>
            <remarks>This method can be called asynchronously and so should only be used by seasoned C# experts. Ensure you use proper locks on thread-unsafe objects</remarks>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time the we add/remove securities from the data feed
            </summary>
            <param name="changes">Security additions/removals for this time step</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnFrameworkSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Used to send security changes to algorithm framework models
            </summary>
            <param name="changes">Security additions/removals for this time step</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.PostInitialize">
            <summary>
            Called by setup handlers after Initialize and allows the algorithm a chance to organize
            the data gather in the Initialize method
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.OnWarmupFinished">
            <summary>
            Called when the algorithm has completed initialization and warm up.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.RemoveSecurity(QuantConnect.Symbol)">
            <summary>
            Removes the security with the specified symbol. This will cancel all
            open orders and then liquidate any existing holdings
            </summary>
            <param name="symbol">The symbol of the security to be removed</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetAlgorithmId(System.String)">
            <summary>
            Set the algorithm Id for this backtest or live run. This can be used to identify the order and equity records.
            </summary>
            <param name="algorithmId">unique 32 character identifier for backtest or live server</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetBrokerageMessageHandler(QuantConnect.Brokerages.IBrokerageMessageHandler)">
            <summary>
            Sets the implementation used to handle messages from the brokerage.
            The default implementation will forward messages to debug or error
            and when a <see cref="F:QuantConnect.Brokerages.BrokerageMessageType.Error"/> occurs, the algorithm
            is stopped.
            </summary>
            <param name="handler">The message handler to use</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetBrokerageModel(QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Sets the brokerage model used to resolve transaction models, settlement models,
            and brokerage specified ordering behaviors.
            </summary>
            <param name="brokerageModel">The brokerage model used to emulate the real
            brokerage</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetAccountCurrency(System.String,System.Nullable{System.Decimal})">
            <summary>
            Sets the account currency cash symbol this algorithm is to manage, as well
            as the starting cash in this currency if given
            </summary>
            <remarks>Has to be called during <see cref="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Initialize"/> before
            calling <see cref="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetCash(System.Decimal)"/> or adding any <see cref="T:QuantConnect.Securities.Security"/></remarks>
            <param name="accountCurrency">The account currency cash symbol to set</param>
            <param name="startingCash">The account currency starting cash to set</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetCash(System.Decimal)">
            <summary>
            Set the starting capital for the strategy
            </summary>
            <param name="startingCash">decimal starting capital, default $100,000</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetCash(System.String,System.Decimal,System.Decimal)">
            <summary>
            Set the cash for the specified symbol
            </summary>
            <param name="symbol">The cash symbol to set</param>
            <param name="startingCash">Decimal cash value of portfolio</param>
            <param name="conversionRate">The current conversion rate for the</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetDateTime(System.DateTime)">
            <summary>
            Set the DateTime Frontier: This is the master time and is
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetStartDate(System.DateTime)">
            <summary>
            Set the start date for the backtest
            </summary>
            <param name="start">Datetime Start date for backtest</param>
            <remarks>Must be less than end date and within data available</remarks>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetEndDate(System.DateTime)">
            <summary>
            Set the end date for a backtest.
            </summary>
            <param name="end">Datetime value for end date</param>
            <remarks>Must be greater than the start date</remarks>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.GetLastKnownPrice(QuantConnect.Securities.Security)">
            <summary>
            Get the last known price using the history provider.
            Useful for seeding securities with the correct price
            </summary>
            <param name="security"><see cref="T:QuantConnect.Securities.Security"/> object for which to retrieve historical data</param>
            <returns>A single <see cref="T:QuantConnect.Data.BaseData"/> object with the last known price</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetRunTimeError(System.Exception)">
            <summary>
            Set the runtime error
            </summary>
            <param name="exception">Represents error that occur during execution</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetFinishedWarmingUp">
            <summary>
            Sets <see cref="P:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.IsWarmingUp"/> to false to indicate this algorithm has finished its warm up
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetHistoryProvider(QuantConnect.Interfaces.IHistoryProvider)">
            <summary>
            Set the historical data provider
            </summary>
            <param name="historyProvider">Historical data provider</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetLiveMode(System.Boolean)">
            <summary>
            Set live mode state of the algorithm run: Public setter for the algorithm property LiveMode.
            </summary>
            <param name="live">Bool live mode flag</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetAlgorithmMode(QuantConnect.AlgorithmMode)">
            <summary>
            Sets the algorithm running mode
            </summary>
            <param name="algorithmMode">Algorithm mode</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetDeploymentTarget(QuantConnect.DeploymentTarget)">
            <summary>
            Sets the algorithm deployment target
            </summary>
            <param name="deploymentTarget">Deployment target</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetLocked">
            <summary>
            Set the algorithm as initialized and locked. No more cash or security changes.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetMaximumOrders(System.Int32)">
            <summary>
            Set the maximum number of orders the algorithm is allowed to process.
            </summary>
            <param name="max">Maximum order count int</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetParameters(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sets the parameters from the dictionary
            </summary>
            <param name="parameters">Dictionary containing the parameter names to values</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.TryConvert``1(Python.Runtime.PyObject,``0@)">
            <summary>
            Tries to convert a PyObject into a C# object
            </summary>
            <typeparam name="T">Type of the C# object</typeparam>
            <param name="pyObject">PyObject to be converted</param>
            <param name="result">C# object that of type T</param>
            <returns>True if successful conversion</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.ToString">
            <summary>
            Returns a <see cref = "T:System.String"/> that represents the current <see cref = "T:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper"/> object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetCurrentSlice(QuantConnect.Data.Slice)">
            <summary>
            Sets the current slice
            </summary>
            <param name="slice">The Slice object</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetApi(QuantConnect.Interfaces.IApi)">
            <summary>
            Provide the API for the algorithm.
            </summary>
            <param name="api">Initiated API</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetObjectStore(QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Sets the object store
            </summary>
            <param name="objectStore">The object store</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Shortable(QuantConnect.Symbol,System.Decimal,System.Nullable{System.Int32})">
            <summary>
            Determines if the Symbol is shortable at the brokerage
            </summary>
            <param name="symbol">Symbol to check if shortable</param>
            <param name="shortQuantity">Order's quantity to check if it is currently shortable, taking into account current holdings and open orders</param>
            <param name="updateOrderId">Optionally the id of the order being updated. When updating an order
            we want to ignore it's submitted short quantity and use the new provided quantity to determine if we
            can perform the update</param>
            <returns>True if the symbol can be shorted by the requested quantity</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.ShortableQuantity(QuantConnect.Symbol)">
            <summary>
            Gets the quantity shortable for the given asset
            </summary>
            <returns>
            Quantity shortable for the given asset. Zero if not
            shortable, or a number greater than zero if shortable.
            </returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Symbol(System.String)">
            <summary>
            Converts the string 'ticker' symbol into a full <see cref="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Symbol(System.String)"/> object
            This requires that the string 'ticker' has been added to the algorithm
            </summary>
            <param name="ticker">The ticker symbol. This should be the ticker symbol
            as it was added to the algorithm</param>
            <returns>The symbol object mapped to the specified ticker</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.Ticker(QuantConnect.Symbol)">
            <summary>
            For the given symbol will resolve the ticker it used at the current algorithm date
            </summary>
            <param name="symbol">The symbol to get the ticker for</param>
            <returns>The mapped ticker for a symbol</returns>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetName(System.String)">
            <summary>
            Sets name to the currently running backtest
            </summary>
            <param name="name">The name for the backtest</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.AddTag(System.String)">
            <summary>
            Adds a tag to the algorithm
            </summary>
            <param name="tag">The tag to add</param>
        </member>
        <member name="M:QuantConnect.AlgorithmFactory.Python.Wrappers.AlgorithmPythonWrapper.SetTags(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Sets the tags for the algorithm
            </summary>
            <param name="tags">The tags</param>
        </member>
    </members>
</doc>
