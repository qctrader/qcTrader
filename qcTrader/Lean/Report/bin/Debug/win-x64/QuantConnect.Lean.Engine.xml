<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QuantConnect.Lean.Engine</name>
    </assembly>
    <members>
        <member name="T:QuantConnect.Lean.Engine.AlgorithmManager">
            <summary>
            Algorithm manager class executes the algorithm and generates and passes through the algorithm events.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.State">
            <summary>
            Publicly accessible algorithm status
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.AlgorithmId">
            <summary>
            Public access to the currently running algorithm id.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.TimeLimit">
            <summary>
            Provides the isolator with a function for verifying that we're not spending too much time in each
            algorithm manager time loop
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.QuitState">
            <summary>
            Quit state flag for the running algorithm. When true the user has requested the backtest stops through a Quit() method.
            </summary>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.Quit(System.String)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.DataPoints">
            <summary>
            Gets the number of data points processed per second
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.AlgorithmHistoryDataPoints">
            <summary>
            Gets the number of data points of algorithm history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.#ctor(System.Boolean,QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.AlgorithmManager"/> class
            </summary>
            <param name="liveMode">True if we're running in live mode, false for backtest mode</param>
            <param name="job">Provided by LEAN when creating a new algo manager. This is the job
            that the algo manager is about to execute. Research and other consumers can provide the
            default value of null</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.Run(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.ISynchronizer,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Lean.Engine.Server.ILeanManager,System.Threading.CancellationToken)">
            <summary>
            Launch the algorithm manager to run this strategy
            </summary>
            <param name="job">Algorithm job</param>
            <param name="algorithm">Algorithm instance</param>
            <param name="synchronizer">Instance which implements <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/>. Used to stream the data</param>
            <param name="transactions">Transaction manager object</param>
            <param name="results">Result handler object</param>
            <param name="realtime">Realtime processing object</param>
            <param name="leanManager">ILeanManager implementation that is updated periodically with the IAlgorithm instance</param>
            <param name="token">Cancellation token</param>
            <remarks>Modify with caution</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.SetStatus(QuantConnect.AlgorithmStatus)">
            <summary>
            Set the quit state.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ProcessVolatilityHistoryRequirements(QuantConnect.Interfaces.IAlgorithm,System.Boolean)">
            <summary>
            Helper method used to process securities volatility history requirements
            </summary>
            <remarks>Implemented as static to facilitate testing</remarks>
            <param name="algorithm">The algorithm instance</param>
            <param name="liveMode">Whether the algorithm is in live mode</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleSplits(QuantConnect.Lean.Engine.DataFeeds.TimeSlice,QuantConnect.Interfaces.IAlgorithm,System.Boolean)">
            <summary>
            Helper method to apply a split to an algorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleDividends(QuantConnect.Lean.Engine.DataFeeds.TimeSlice,QuantConnect.Interfaces.IAlgorithm,System.Boolean)">
            <summary>
            Helper method to apply a dividend to an algorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleSplitSymbols(QuantConnect.Data.Market.Splits,System.Collections.Generic.List{QuantConnect.Data.Market.Split})">
            <summary>
            Keeps track of split warnings so we can later liquidate option contracts
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ProcessSplitSymbols(QuantConnect.Interfaces.IAlgorithm,System.Collections.Generic.List{QuantConnect.Data.Market.Split},System.Collections.Generic.List{QuantConnect.Data.Market.Delisting})">
            <summary>
            Liquidate option contact holdings who's underlying security has split
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ApplySplitOrDividendToVolatilityModel(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Securities.Security,System.Boolean,QuantConnect.DataNormalizationMode)">
            <summary>
            Warms up the security's volatility model in the case of a split or dividend to avoid discontinuities when data is raw or in live mode
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.CreateTokenBucket(QuantConnect.Packets.LeakyBucketControlParameters)">
            <summary>
            Constructs the correct <see cref="T:QuantConnect.Util.RateLimit.ITokenBucket"/> instance per the provided controls.
            The provided controls will be null when
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.IIsolatorLimitResultProvider"/> that tracks the algorithm
            manager's time loops and enforces a maximum amount of time that each time loop may take to execute.
            The isolator uses the result provided by <see cref="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsWithinLimit"/> to determine if it should
            terminate the algorithm for violation of the imposed limits.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.AdditionalTimeBucket">
            <summary>
            Gets the additional time bucket which is responsible for tracking additional time requested
            for processing via long-running scheduled events. In LEAN, we use the <see cref="T:QuantConnect.Util.RateLimit.LeakyBucket"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.#ctor(QuantConnect.Util.RateLimit.ITokenBucket,System.TimeSpan)">
            <summary>
            Initializes a new instance of <see cref="T:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager"/> to manage the
            creation of <see cref="T:QuantConnect.IsolatorLimitResult"/> instances as it pertains to the
            algorithm manager's time loop
            </summary>
            <param name="additionalTimeBucket">Provides a bucket of additional time that can be requested to be
            spent to give execution time for things such as training scheduled events</param>
            <param name="timeLoopMaximum">Specifies the maximum amount of time the algorithm is permitted to
            spend in a single time loop. This value can be overriden if certain actions are taken by the
            algorithm, such as invoking the training methods.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.StartNewTimeStep">
            <summary>
            Invoked by the algorithm at the start of each time loop. This resets the current time step
            elapsed time.
            </summary>
            <remarks>
            This class is the result of a mechanical refactor with the intention of preserving all existing
            behavior, including setting the <code>_currentTimeStepTime</code> to <see cref="F:System.DateTime.MinValue"/>
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.StopEnforcingTimeLimit">
            <summary>
            Stops this instance from tracking the algorithm manager's time loop elapsed time.
            This is invoked at the end of the algorithm to prevent the isolator from terminating
            the algorithm during final clean up and shutdown.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsWithinLimit">
            <summary>
            Determines whether or not the algorithm time loop is considered within the limits
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.RequestAdditionalTime(System.Int32)">
             <summary>
             Requests additional time to continue executing the current time step.
             At time of writing, this is intended to be used to provide training scheduled events
             additional time to allow complex training models time to execute while also preventing
             abuse by enforcing certain control parameters set via the job packet.
            
             Each time this method is invoked, this time limit manager will increase the allowable
             execution time by the specified number of whole minutes
             </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.TryRequestAdditionalTime(System.Int32)">
             <summary>
             Attempts to requests additional time to continue executing the current time step.
             At time of writing, this is intended to be used to provide training scheduled events
             additional time to allow complex training models time to execute while also preventing
             abuse by enforcing certain control parameters set via the job packet.
            
             Each time this method is invoked, this time limit manager will increase the allowable
             execution time by the specified number of whole minutes
             </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsOutOfTime(System.TimeSpan@)">
            <summary>
            Determines whether or not the algorithm should be terminated due to exceeding the time limits
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.GetCurrentTimeStepElapsed">
            <summary>
            Gets the current amount of time that has elapsed since the beginning of the
            most recent algorithm manager time loop
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.AggregationManager">
            <summary>
            Aggregates ticks and bars based on given subscriptions.
            Current implementation is based on <see cref="T:QuantConnect.Data.Consolidators.IDataConsolidator"/> that consolidates ticks and put them into enumerator.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Initialize(QuantConnect.Data.DataAggregatorInitializeParameters)">
            <summary>
            Initialize this instance
            </summary>
            <param name="parameters">The parameters dto instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Add(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Add new subscription to current <see cref="T:QuantConnect.Data.IDataAggregator"/> instance
            </summary>
            <param name="dataConfig">defines the parameters to subscribe to a data feed</param>
            <param name="newDataAvailableHandler">handler to be fired on new data available</param>
            <returns>The new enumerator for this subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Remove(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Removes the handler with the specified identifier
            </summary>
            <param name="dataConfig">Subscription data configuration to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Update(QuantConnect.Data.BaseData)">
            <summary>
            Add new data to aggregator
            </summary>
            <param name="input">The new data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Dispose">
            <summary>
            Dispose of the aggregation manager.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.GetConsolidator(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets the consolidator to aggregate data for the given config
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider">
            <summary>
            An instance of the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> that will download and update data files as needed via QC's Api.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.Fetch(System.String)">
            <summary>
            Retrieves data to be used in an algorithm.
            If file does not exist, an attempt is made to download them from the api
            </summary>
            <param name="key">File path representing where the data requested</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.NeedToDownload(System.String)">
            <summary>
            Main filter to determine if this file needs to be downloaded
            </summary>
            <param name="filePath">File we are looking at</param>
            <returns>True if should download</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.DownloadData(System.String)">
            <summary>
            Attempt to download data using the Api for and return a FileStream of that data.
            </summary>
            <param name="filePath">The path to store the file</param>
            <returns>A FileStream of the data</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.IsAuxiliaryData(System.String)">
            <summary>
            Helper method to determine if this filepath is auxiliary data
            </summary>
            <param name="filepath">The target file path</param>
            <returns>True if this file is of auxiliary data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BacktestingChainProvider">
            <summary>
            Base backtesting cache provider which will source symbols from local zip files
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BacktestingChainProvider.DataCacheProvider">
            <summary>
            The data cache instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingChainProvider.#ctor(QuantConnect.Interfaces.IDataCacheProvider)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingChainProvider.GetSymbols(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Get the contract symbols associated with the given canonical symbol and date
            </summary>
            <param name="canonicalSymbol">The canonical symbol</param>
            <param name="date">The date to search for</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingChainProvider.IsContractExpired(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Helper method to determine if a contract is expired for the requested date
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that reads the list of contracts from open interest zip data files
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider.#ctor(QuantConnect.Interfaces.IDataCacheProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="dataCacheProvider">The data cache provider instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider.GetSymbol(QuantConnect.Symbol)">
            <summary>
            Helper method to get the symbol to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BacktestingOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that reads the list of contracts from open interest zip data files
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingOptionChainProvider.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Interfaces.IMapFileProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="dataCacheProvider">The data cache provider instance to use</param>
            <param name="mapFileProvider">The map file provider instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of option contracts for a given underlying symbol
            </summary>
            <param name="symbol">The option or the underlying symbol to get the option chain for.
            Providing the option allows targetting an option ticker different than the default e.g. SPXW</param>
            <param name="date">The date for which to request the option chain (only used in backtesting)</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataCollectionAggregatorReader">
            <summary>
            Data source reader that will aggregate data points into a base data collection
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataCollectionAggregatorReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataCacheProvider">This provider caches files if needed</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataCollectionAggregatorReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange">
            <summary>
            Provides a means of distributing output from enumerators from a dedicated separate thread
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SleepInterval">
            <summary>
            Gets or sets how long this thread will sleep when no data is available
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Name">
            <summary>
            Gets a name for this exchange
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange"/>
            </summary>
            <param name="name">A name for this exchange</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler)">
            <summary>
            Adds the enumerator to this exchange. If it has already been added
            then it will remain registered in the exchange only once
            </summary>
            <param name="handler">The handler to use when this symbol's data is encountered</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler},System.Action{QuantConnect.Data.BaseData})">
            <summary>
            Adds the enumerator to this exchange. If it has already been added
            then it will remain registered in the exchange only once
            </summary>
            <param name="symbol">A unique symbol used to identify this enumerator</param>
            <param name="enumerator">The enumerator to be added</param>
            <param name="shouldMoveNext">Function used to determine if move next should be called on this
            enumerator, defaults to always returning true</param>
            <param name="enumeratorFinished">Delegate called when the enumerator move next returns false</param>
            <param name="handleData">Handler for data if HandlesData=true</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetErrorHandler(System.Func{System.Exception,System.Boolean})">
            <summary>
            Sets the specified function as the error handler. This function
            returns true if it is a fatal error and queue consumption should
            cease.
            </summary>
            <param name="isFatalError">The error handling function to use when an
            error is encountered during queue consumption. Returns true if queue
            consumption should be stopped, returns false if queue consumption should
            continue</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.RemoveEnumerator(QuantConnect.Symbol)">
            <summary>
            Removes and returns enumerator handler with the specified symbol.
            The removed handler is returned, null if not found
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Start">
            <summary>
            Begins consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> on
            a separate thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop">
            <summary>
            Ends consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.ConsumeEnumerators">
            <summary> Entry point for queue consumption </summary>
            <remarks> This function only returns after <see cref="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop"/> is called or the token is cancelled</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler">
            <summary>
            Handler used to manage a single enumerator's move next/end of stream behavior
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished">
            <summary>
            Event fired when MoveNext returns false
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Symbol">
            <summary>
            A unique symbol used to identify this enumerator
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Enumerator">
            <summary>
            The enumerator this handler handles
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler"/> class
            </summary>
            <param name="symbol">The symbol to identify this enumerator</param>
            <param name="enumerator">The enumeator this handler handles</param>
            <param name="shouldMoveNext">Predicate function used to determine if we should call move next
            on the symbol's enumerator</param>
            <param name="handleData">Handler for data if HandlesData=true</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.OnEnumeratorFinished">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.ShouldMoveNext">
            <summary>
            Returns true if this enumerator should move next
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.HandleData(QuantConnect.Data.BaseData)">
            <summary>
            Handles the specified data.
            </summary>
            <param name="data">The data to be handled</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider">
            <summary>
            Base downloader implementation with some helper methods
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider._singleDownloadSynchronizer">
            <summary>
            Synchronizer in charge of guaranteeing a single download per path request
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider.DownloadOnce(System.String,System.Action{System.String})">
            <summary>
            Helper method which guarantees each requested key is downloaded only once concurrently if required based on <see cref="M:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider.NeedToDownload(System.String)"/>
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <param name="download">The download operation we want to perform once concurrently per key</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider.GetStream(System.String)">
            <summary>
            Get's the stream for a given file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDownloaderDataProvider.NeedToDownload(System.String)">
            <summary>
            Main filter to determine if this file needs to be downloaded
            </summary>
            <param name="filePath">File we are looking at</param>
            <returns>True if should download</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader">
            <summary>
            A base class for implementations of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.IsLiveMode">
            <summary>
            True if we're in live mode, false for backtesting
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.DataCacheProvider">
            <summary>
            The data cache provider to use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.ObjectStore">
            <summary>
            The object store to use
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.Boolean,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.CreateStreamReader(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Interfaces.IStreamReader"/> for the specified <paramref name="subscriptionDataSource"/>
            </summary>
            <param name="subscriptionDataSource">The source to produce an <see cref="T:QuantConnect.Interfaces.IStreamReader"/> for</param>
            <returns>A new instance of <see cref="T:QuantConnect.Interfaces.IStreamReader"/> to read the source, or null if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.HandleRemoteSourceFile(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Opens up an IStreamReader for a remote file source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that will cache by date future contracts returned by another future chain provider.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider.#ctor(QuantConnect.Interfaces.IFutureChainProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider"/> class
            </summary>
            <param name="futureChainProvider"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that will cache by date option contracts returned by another option chain provider.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider.#ctor(QuantConnect.Interfaces.IOptionChainProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider"/> class
            </summary>
            <param name="optionChainProvider"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of option contracts for a given underlying symbol
            </summary>
            <param name="symbol">The option or the underlying symbol to get the option chain for.
            Providing the option allows targetting an option ticker different than the default e.g. SPXW</param>
            <param name="date">The date for which to request the option chain (only used in backtesting)</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader">
            <summary>
            Collection Subscription Factory takes a BaseDataCollection from BaseData factories
            and yields it one point at a time to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataCacheProvider">Used to cache data for requested from the IDataProvider</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError">
            <summary>
            Event fired when an exception is thrown during a call to
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError"/> event
            </summary>
            <param name="line">The line that caused the exception</param>
            <param name="exception">The exception that was caught</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider">
            <summary>
            This data provider will wrap and use multiple data providers internally in the provided order
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider.NewDataRequest">
            <summary>
            Event raised each time data fetch is finished (successfully or not)
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider.#ctor">
            <summary>
            Creates a new instance and initialize data providers used
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider.Fetch(System.String)">
            <summary>
            Retrieves data to be used in an algorithm
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider.OnNewDataRequest(System.Object,QuantConnect.Interfaces.DataProviderNewDataRequestEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CompositeDataProvider.NewDataRequest"/> event
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CompositeTimeProvider">
            <summary>
            The composite time provider will source it's current time using the smallest time from the given providers
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CompositeTimeProvider.#ctor(System.Collections.Generic.IEnumerable{QuantConnect.ITimeProvider})">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeProviders">The time providers to use. Will default to the real time provider if empty</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CompositeTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs">
            <summary>
            Event arguments for the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader"/>'s CreateStreamReader event
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Date">
            <summary>
            Gets the date of the source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Source">
            <summary>
            Gets the source that caused the error
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.#ctor(System.DateTime,QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs"/> class
            </summary>
            <param name="date">The date of the source</param>
            <param name="source">The source that cause the error</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager">
            <summary>
            Helper class to keep track of required internal currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>.
            This class is used by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.#ctor(QuantConnect.Securities.CashBook,QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Interfaces.ISecurityService,QuantConnect.Resolution)">
            <summary>
            Creates a new instance
            </summary>
            <param name="cashBook">The cash book instance</param>
            <param name="securityManager">The SecurityManager, required by the cash book for creating new securities</param>
            <param name="subscriptionManager">The SubscriptionManager, required by the cash book for creating new subscription data configs</param>
            <param name="securityService">The SecurityService, required by the cash book for creating new securities</param>
            <param name="defaultResolution">The default resolution to use for the internal subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetSubscriptionDataConfigToRemove(QuantConnect.Symbol)">
            <summary>
            Will verify if there are any <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to be removed
            for a given added <see cref="T:QuantConnect.Symbol"/>.
            </summary>
            <param name="addedSymbol">The symbol that was added to the data feed system</param>
            <returns>The SubscriptionDataConfig to be removed, null if none</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.UpdatePendingSubscriptionDataConfigs(QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Will update pending currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>
            </summary>
            <returns>True when there are pending currency subscriptions <see cref="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetPendingSubscriptionDataConfigs"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetPendingSubscriptionDataConfigs">
            <summary>
            Will return any pending internal currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and remove them as pending.
            </summary>
            <returns>Will return the <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to be added</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.EnsureCurrencySubscriptionDataConfigs(QuantConnect.Data.UniverseSelection.SecurityChanges,QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Checks the current <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and adds new necessary currency pair feeds to provide real time conversion data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider">
            <summary>
            Specifies data channel settings
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider.Initialize(QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Initializes the instance with an algorithm node packet
            </summary>
            <param name="packet">Algorithm node packet</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider.ShouldStreamSubscription(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            True if this subscription request should be streamed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider.IsStreamingType(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Returns true if the data type for the given subscription configuration supports streaming
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket">
            <summary>
            Defines a container type to hold data produced by a data feed subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Security">
            <summary>
            The security
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Configuration">
            <summary>
            The subscription configuration that produced this data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Count">
            <summary>
            Gets the number of data points held within this packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Data">
            <summary>
            The data for the security
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.IsSubscriptionRemoved">
            <summary>
            Gets whether or not this packet should be filtered out due to the subscription being removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Interfaces.ISecurityPrice,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Util.IReadOnlyRef{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket"/> class
            </summary>
            <param name="security">The security whose data is held in this packet</param>
            <param name="configuration">The subscription configuration that produced this data</param>
            <param name="isSubscriptionRemoved">Reference to whether or not the subscription has since been removed, defaults to false</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Interfaces.ISecurityPrice,QuantConnect.Data.SubscriptionDataConfig,System.Collections.Generic.List{QuantConnect.Data.BaseData},QuantConnect.Util.IReadOnlyRef{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket"/> class
            </summary>
            <param name="security">The security whose data is held in this packet</param>
            <param name="configuration">The subscription configuration that produced this data</param>
            <param name="data">The data to add to this packet. The list reference is reused
            internally and NOT copied.</param>
            <param name="isSubscriptionRemoved">Reference to whether or not the subscription has since been removed, defaults to false</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Add(QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified data to this packet
            </summary>
            <param name="data">The data to be added to this packet</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataManager">
            <summary>
            DataManager will manage the subscriptions for both the DataFeeds and the SubscriptionManager
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.DataManager._subscriptionManagerSubscriptions">
            There is no ConcurrentHashSet collection in .NET,
            so we use ConcurrentDictionary with byte value to minimize memory usage
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionAdded">
            <summary>
            Event fired when a new subscription is added
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionRemoved">
            <summary>
            Event fired when an existing subscription is removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.#ctor(QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.DataFeeds.UniverseSelection,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.ITimeKeeper,QuantConnect.Securities.MarketHoursDatabase,System.Boolean,QuantConnect.Securities.IRegisteredSecurityDataTypesProvider,QuantConnect.Interfaces.IDataPermissionManager)">
            <summary>
            Creates a new instance of the DataManager
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.DataFeedSubscriptions">
            <summary>
            Gets the data feed subscription collection
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveAllSubscriptions">
            <summary>
            Will remove all current <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> to provide data for the specified security.
            </summary>
            <param name="request">Defines the <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to be added</param>
            <returns>True if the subscription was created and added successfully, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>, if it exists
            </summary>
            <param name="configuration">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> of the subscription to remove</param>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>.
            Default value, null, will remove all universes</param>
            <returns>True if the subscription was successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveSubscriptionInternal(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.Universe,System.Boolean)">
            <summary>
            Removes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>, if it exists
            </summary>
            <param name="configuration">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> of the subscription to remove</param>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>.
            Default value, null, will remove all universes</param>
            <param name="forceSubscriptionRemoval">We force the subscription removal by marking it as removed from universe, so that all it's data is dropped</param>
            <returns>True if the subscription was successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.OnSubscriptionAdded(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionAdded"/> event
            </summary>
            <param name="subscription">The added subscription</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.OnSubscriptionRemoved(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionRemoved"/> event
            </summary>
            <param name="subscription">The removed subscription</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerSubscriptions">
            <summary>
            Gets all the current data config subscriptions that are being processed for the SubscriptionManager
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerGetOrAdd(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets existing or adds new <see cref="T:QuantConnect.Data.SubscriptionDataConfig" />
            </summary>
            <returns>Returns the SubscriptionDataConfig instance used</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveSubscriptionDataConfig(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Will try to remove a <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and update the corresponding
            consumers accordingly
            </summary>
            <param name="subscription">The <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> owning the configuration to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerCount">
            <summary>
            Returns the amount of data config subscriptions processed for the SubscriptionManager
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.AvailableDataTypes">
            <summary>
            The different <see cref="T:QuantConnect.TickType" /> each <see cref="T:QuantConnect.SecurityType" /> supports
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.Add(System.Type,QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,QuantConnect.DataNormalizationMode,QuantConnect.DataMappingMode,System.UInt32)">
            <summary>
            Creates and adds a list of <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /> for a given symbol and configuration.
            Can optionally pass in desired subscription data type to use.
            If the config already existed will return existing instance instead
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.Add(QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.List{System.Tuple{System.Type,QuantConnect.TickType}},QuantConnect.DataNormalizationMode,QuantConnect.DataMappingMode,System.UInt32)">
            <summary>
            Creates and adds a list of <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /> for a given symbol and configuration.
            Can optionally pass in desired subscription data types to use.
             If the config already existed will return existing instance instead
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.LookupSubscriptionConfigDataTypes(QuantConnect.SecurityType,QuantConnect.Resolution,System.Boolean)">
            <summary>
            Get the data feed types for a given <see cref="T:QuantConnect.SecurityType" /> <see cref="T:QuantConnect.Resolution" />
            </summary>
            <param name="symbolSecurityType">The <see cref="T:QuantConnect.SecurityType" /> used to determine the types</param>
            <param name="resolution">The resolution of the data requested</param>
            <param name="isCanonical">Indicates whether the security is Canonical (future and options)</param>
            <returns>Types that should be added to the <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /></returns>
            <remarks>TODO: data type additions are very related to ticktype and should be more generic/independent of each other</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.GetSubscriptionDataConfigs(QuantConnect.Symbol,System.Boolean)">
            <summary>
            Gets a list of all registered <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> for a given <see cref="T:QuantConnect.Symbol"/>
            </summary>
            <remarks>Will not return internal subscriptions by default</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager">
            <summary>
            Entity in charge of handling data permissions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.DataChannelProvider">
            <summary>
            The data channel provider instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.Initialize(QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Initialize the data permission manager
            </summary>
            <param name="job">The job packet</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.AssertConfiguration(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.DateTime)">
            <summary>
            Will assert the requested configuration is valid for the current job
            </summary>
            <param name="subscriptionRequest">The data subscription configuration to assert</param>
            <param name="startTimeLocal">The start time of this request</param>
            <param name="endTimeLocal">The end time of this request</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager">
            <summary>
            This is an implementation of <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> used to handle multiple live datafeeds
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.#ctor(QuantConnect.Interfaces.IAlgorithmSettings)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.DataHandlers">
            <summary>
            Collection of data queue handles being used
            </summary>
            <remarks>Protected for testing purposes</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.HasUniverseProvider">
            <summary>
            True if the composite queue handler has any <see cref="T:QuantConnect.Interfaces.IDataQueueUniverseProvider"/> instance
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.UnsupportedConfiguration">
            <summary>
            Event triggered when an unsupported configuration is detected
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.Subscribe(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Subscribe to the specified configuration
            </summary>
            <param name="dataConfig">defines the parameters to subscribe to a data feed</param>
            <param name="newDataAvailableHandler">handler to be fired on new data available</param>
            <returns>The new enumerator for this subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.Unsubscribe(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Removes the specified configuration
            </summary>
            <param name="dataConfig">Subscription config to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.SetJob(QuantConnect.Packets.LiveNodePacket)">
            <summary>
            Sets the job we're subscribing for
            </summary>
            <param name="job">Job we're subscribing for</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.IsConnected">
            <summary>
            Returns whether the data provider is connected
            </summary>
            <returns>true if the data provider is connected</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.LookupSymbols(QuantConnect.Symbol,System.Boolean,System.String)">
            <summary>
            Method returns a collection of Symbols that are available at the data source.
            </summary>
            <param name="symbol">Symbol to lookup</param>
            <param name="includeExpired">Include expired contracts</param>
            <param name="securityCurrency">Expected security currency(if any)</param>
            <returns>Enumerable of Symbols, that are associated with the provided Symbol</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.CanPerformSelection">
            <summary>
            Returns whether selection can take place or not.
            </summary>
            <remarks>This is useful to avoid a selection taking place during invalid times, for example IB reset times or when not connected,
            because if allowed selection would fail since IB isn't running and would kill the algorithm</remarks>
            <returns>True if selection can take place</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager.InitializeFrontierTimeProvider">
            <summary>
            Creates the frontier time provider instance
            </summary>
            <remarks>Protected for testing purposes</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider">
            <summary>
            Default file provider functionality that retrieves data from disc to be used in an algorithm
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.NewDataRequest">
            <summary>
            Event raised each time data fetch is finished (successfully or not)
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.Fetch(System.String)">
            <summary>
            Retrieves data from disc to be used in an algorithm
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.Dispose">
            <summary>
            The stream created by this type is passed up the stack to the IStreamReader
            The stream is closed when the StreamReader that wraps this stream is disposed</summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.OnNewDataRequest(QuantConnect.Interfaces.DataProviderNewDataRequestEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.NewDataRequest"/> event
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider">
            <summary>
            Data provider which downloads data using an <see cref="T:QuantConnect.IDataDownloader"/> or <see cref="T:QuantConnect.Interfaces.IBrokerage"/> implementation
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.DiskSynchronizer">
            <summary>
            Synchronizer in charge of guaranteeing a single operation per file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.#ctor(QuantConnect.IDataDownloader)">
            <summary>
            Creates a new instance using a target data downloader used for testing
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.Fetch(System.String)">
            <summary>
            Determines if it should downloads new data and retrieves data from disc
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.GetDownloadedData(System.Collections.Generic.IEnumerable{QuantConnect.DataDownloaderGetParameters},QuantConnect.Symbol,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Type)">
            <summary>
            Retrieves downloaded data grouped by symbol based on <see cref="T:QuantConnect.Interfaces.IDownloadProvider"/>.
            </summary>
            <param name="downloaderDataParameters">Parameters specifying the data to be retrieved.</param>
            <param name="symbol">Represents a unique security identifier, generate by ticker name.</param>
            <param name="exchangeTimeZone">The time zone of the exchange where the symbol is traded.</param>
            <param name="dataTimeZone">The time zone in which the data is represented.</param>
            <param name="dataType">The type of data to be retrieved. (e.g. <see cref="T:QuantConnect.Data.Market.TradeBar"/>)</param>
            <returns>An IEnumerable containing groups of data grouped by symbol. Each group contains data related to a specific symbol.</returns>
            <exception cref="T:System.ArgumentException"> Thrown when the downloaderDataParameters collection is null or empty.</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.GetStream(System.String)">
            <summary>
            Get's the stream for a given file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.NeedToDownload(System.String)">
            <summary>
            Main filter to determine if this file needs to be downloaded
            </summary>
            <param name="filePath">File we are looking at</param>
            <returns>True if should download</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DownloaderDataProvider.FilterAndGroupDownloadDataBySymbol(System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData},QuantConnect.Symbol,System.Type,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.DateTime,System.DateTime)">
            <summary>
            Filters and groups the provided download data by symbol, based on specified criteria.
            </summary>
            <param name="downloadData">The collection of download data to process.</param>
            <param name="symbol">The symbol to filter the data for.</param>
            <param name="dataType">The type of data to filter for.</param>
            <param name="exchangeTimeZone">The time zone of the exchange.</param>
            <param name="dataTimeZone">The desired time zone for the data.</param>
            <param name="downloaderStartTimeUtc">The start time of data downloading in UTC.</param>
            <param name="downloaderEndTimeUtc">The end time of data downloading in UTC.</param>
            <returns>
            An enumerable collection of groupings of download data, grouped by symbol.
            </returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator">
            <summary>
            Auxiliary data enumerator that will, initialize and call the <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)"/>
            implementation each time there is a new tradable day for every <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider"/>
            provided.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Config">
            <summary>
            The associated data configuration
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider[],QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier,System.DateTime)">
            <summary>
            Creates a new instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="tradableDateEventProviders">The tradable dates event providers</param>
            <param name="tradableDayNotifier">Tradable dates provider</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element.
            </summary>
            <returns>Always true</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.NewTradableDate(System.Object,QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Handle a new tradable date, drives the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Initialize">
            <summary>
            Initializes the underlying tradable data event providers
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Dispose">
            <summary>
            Dispose of the Stream Reader and close out the source stream and file connections.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Current">
            <summary>
            Last read BaseData object from this type and source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/>
            that aggregates an underlying <see cref="T:System.Collections.Generic.IEnumerator`1"/> into a single
            data packet
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator"/> class
            This will aggregate instances emitted from the underlying enumerator and tag them with the
            specified symbol
            </summary>
            <param name="enumerator">The underlying enumerator to aggregate</param>
            <param name="symbol">The symbol to place on the aggregated collection</param>
            <param name="liveMode">True if running in live mode</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.CreateCollection(QuantConnect.Symbol,System.DateTime,System.DateTime)">
            <summary>
            Creates a new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/>.
            </summary>
            <param name="symbol">The base data collection symbol</param>
            <param name="time">The start time of the collection</param>
            <param name="endTime">The end time of the collection</param>
            <returns>A new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.Add(QuantConnect.Data.UniverseSelection.BaseDataCollection,QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData"/> to the current collection
            </summary>
            <param name="collection">The collection to be added to</param>
            <param name="current">The data to be added</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.IsValid(QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Determines if a given data point is valid and can be emitted
            </summary>
            <param name="collection">The collection to be emitted</param>
            <returns>True if its a valid data point</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator">
            <summary>
            Enumerator that will concatenate enumerators together sequentially enumerating them in the provided order
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Current">
            <summary>
            The current BaseData object
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.CanEmitNull">
            <summary>
            True if emitting a null data point is expected
            </summary>
            <remarks>Warmup enumerators are not allowed to return true and setting current to Null, this is because it's not a valid behavior for backtesting enumerators,
            for example <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.#ctor(System.Boolean,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Creates a new instance
            </summary>
            <param name="skipDuplicateEndTimes">True will skip data points from enumerators if before or at the last end time</param>
            <param name="enumerators">The sequence of enumerators to concatenate. Note that the order here matters, it will consume enumerators
            and dispose of them, even if they return true and their current is null, except for the last which will be kept!</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator">
            <summary>
            Enumerates live futures symbol universe data into <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator"/> class.
            </summary>
            <param name="subscriptionRequest">The subscription request to be used</param>
            <param name="universeProvider">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider to be used</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Current">
            <summary>
            Returns current futures chain enumerator position
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns current futures chain enumerator position
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator">
            <summary>
            Enumerates live options symbol universe data into <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/> instances
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Underlying">
            <summary>
            Gets the enumerator for the underlying asset
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator"/> class.
            </summary>
            <param name="subscriptionRequest">The subscription request to be used</param>
            <param name="underlying">Underlying enumerator</param>
            <param name="universeProvider">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider to be used</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Current">
            <summary>
            Returns current option chain enumerator position
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns current option chain enumerator position
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Delisting"/> events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.DelistingDate">
            <summary>
            The delisting date
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.MapFile">
            <summary>
            The current instance being used
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.Config">
            <summary>
            The associated configuration
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for delistings
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New delisting event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.InitializeMapFile">
            <summary>
            Initializes the factor file to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Dividend"/> events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.FactorFile">
            <summary>
            The current instance being used
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.Config">
            <summary>
            The associated configuration
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for dividends and returns them
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New Dividend event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.InitializeFactorFile">
            <summary>
            Initializes the factor file to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that relies on the
            <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Enqueue(`0)"/> method being called and only ends when <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Stop"/>
            is called
            </summary>
            <typeparam name="T">The item type yielded by the enumerator</typeparam>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Count">
            <summary>
            Gets the current number of items held in the internal queue
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.HasFinished">
            <summary>
            Returns true if the enumerator has finished and will not accept any more data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1"/> class
            </summary>
            <param name="blocking">Specifies whether or not to use the blocking behavior</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Enqueue(`0)">
            <summary>
            Enqueues the new data into this enumerator
            </summary>
            <param name="data">The data to be enqueued</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Stop">
            <summary>
            Signals the enumerator to stop enumerating when the items currently
            held inside are gone. No more items will be added to this enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that reads
            an entire <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> into a single <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/>
            to be emitted on the tradable date at midnight
            </summary>
            <remarks>This enumerator factory is currently only used in backtesting with coarse data</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory.#ctor(QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Instanciates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory"/>
            </summary>
            <param name="objectStore">The object store to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory">
            <summary>
            Provides a default implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that uses
            <see cref="T:QuantConnect.Data.BaseData"/> factory methods for reading sources
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.#ctor(QuantConnect.Interfaces.IOptionChainProvider,QuantConnect.Interfaces.IFutureChainProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="optionChainProvider">The option chain provider</param>
            <param name="futureChainProvider">The future chain provider</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.CorporateEventEnumeratorFactory">
            <summary>
            Helper class used to create the corporate event providers
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider"/>, <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider"/>,
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider"/>, <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.CorporateEventEnumeratorFactory.CreateEnumerators(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier,QuantConnect.Interfaces.IMapFileProvider,System.DateTime,System.DateTime,System.Boolean)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator"/> that will hold the
            corporate event providers
            </summary>
            <param name="rawDataEnumerator">The underlying raw data enumerator</param>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">Used for getting factor files</param>
            <param name="tradableDayNotifier">Tradable dates provider</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
            <param name="endTime">
            End date for the data request.
            This will be used for <see cref="F:QuantConnect.DataNormalizationMode.ScaledRaw"/> data normalization mode to adjust prices to the given end date
            </param>
            <param name="enablePriceScaling">Applies price factor</param>
            <returns>The new auxiliary data enumerator</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> to handle live custom data.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.#ctor(QuantConnect.ITimeProvider,QuantConnect.Interfaces.IObjectStore,System.Func{System.DateTime,System.DateTime},System.Nullable{System.TimeSpan})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="timeProvider">Time provider from data feed</param>
            <param name="objectStore">The object store to use</param>
            <param name="dateAdjustment">Func that allows adjusting the datetime to use</param>
            <param name="minimumIntervalCheck">Allows specifying the minimum interval between each enumerator refresh and data check, default is 30 minutes</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request.
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.GetSubscriptionDataSourceReader(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,QuantConnect.Data.BaseData,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Gets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> for the specified source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> for the <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverse"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
            <param name="symbolUniverse">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider instance used to determine when bars are completed and can be emitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that used the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/>
            </summary>
            <remarks>Only used on backtesting by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Interfaces.IAlgorithm,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="resultHandler">The result handler for the algorithm</param>
            <param name="mapFileProvider">The map file provider</param>
            <param name="factorFileProvider">The factor file provider</param>
            <param name="cacheProvider">Provider used to get data when it is not present on disk</param>
            <param name="algorithm">The algorithm instance to use</param>
            <param name="enablePriceScaling">Applies price factor</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/> to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> to emit
            ticks based on <see cref="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.GetTriggerTimes(System.DateTime,System.DateTime,QuantConnect.Securities.MarketHoursDatabase)"/>, allowing universe
            selection to fire at planned times.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory.#ctor(QuantConnect.Data.UniverseSelection.ITimeTriggeredUniverse,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="universe">The user defined universe</param>
            <param name="marketHoursDatabase">The market hours database</param>
            <param name="timeProvider">The time provider</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator">
            <summary>
            Provides the ability to fast forward an enumerator based on the age of the data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.ITimeProvider,NodaTime.DateTimeZone,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator"/> class
            </summary>
            <param name="enumerator">The source enumerator</param>
            <param name="timeProvider">A time provider used to determine age of data</param>
            <param name="timeZone">The data's time zone</param>
            <param name="maximumDataAge">The maximum age of data allowed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator">
            <summary>
            The FillForwardEnumerator wraps an existing base data enumerator and inserts extra 'base data' instances
            on a specified fill forward resolution
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Exchange">
            <summary>
            The exchange used to determine when to insert fill forward data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,System.TimeSpan,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> class that accepts
            a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
            and changing as the enumeration progresses
            </summary>
            <param name="enumerator">The source enumerator to be filled forward</param>
            <param name="exchange">The exchange used to determine when to insert fill forward data</param>
            <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
            <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
            <param name="subscriptionEndTime">The end time of the subscrition, once passing this date the enumerator will stop</param>
            <param name="dataResolution">The source enumerator's data resolution</param>
            <param name="dataTimeZone">The time zone of the underlying source data. This is used for rounding calculations and
            is NOT the time zone on the BaseData instances (unless of course data time zone equals the exchange time zone)</param>
            <param name="dailyStrictEndTimeEnabled">True if daily strict end times are enabled</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
            <summary>
            Determines whether or not fill forward is required, and if true, will produce the new fill forward data
            </summary>
            <param name="fillForwardResolution"></param>
            <param name="previous">The last piece of data emitted by this enumerator</param>
            <param name="next">The next piece of data on the source enumerator</param>
            <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
            <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.GetReferenceDateIntervals(System.DateTime,System.TimeSpan)">
            <summary>
            Get potential next fill forward bars.
            </summary>
            <remarks>Special case where fill forward resolution and data resolution are equal</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.GetReferenceDateIntervals(System.DateTime,System.TimeSpan,System.TimeSpan)">
            <summary>
            Get potential next fill forward bars.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.RoundDown(System.DateTime,System.TimeSpan)">
            <summary>
            We need to round down in data timezone.
            For example GH issue 4392: Forex daily data, exchange tz time is 8PM, but time in data tz is 12AM
            so rounding down on exchange tz will crop it, while rounding on data tz will return the same data point time.
            Why are we even doing this? being able to determine the next valid data point for a resolution from a data point that might be in another resolution
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1">
            <summary>
            Enumerator that allow applying a filtering function
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,System.Boolean})">
            <summary>
            Creates a new instance
            </summary>
            <param name="enumerator">The underlying enumerator to filter on</param>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1.Dispose">
            <summary>
            Disposes the FilterEnumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1.MoveNext">
            <summary>
            Moves the FilterEnumerator to the next item
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1.Reset">
            <summary>
            Resets the FilterEnumerator
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FilterEnumerator`1.Current">
            <summary>
            Gets the current item in the FilterEnumerator
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that will not emit
            data ahead of the frontier as specified by an instance of <see cref="T:QuantConnect.ITimeProvider"/>.
            An instance of <see cref="T:QuantConnect.TimeZoneOffsetProvider"/> is used to convert between UTC
            and the data's native time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.ITimeProvider,QuantConnect.TimeZoneOffsetProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator"/> class
            </summary>
            <param name="enumerator">The underlying enumerator to make frontier aware</param>
            <param name="timeProvider">The time provider used for resolving the current frontier time</param>
            <param name="offsetProvider">An offset provider used for converting the frontier UTC time into the data's native time zone</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider">
            <summary>
            Interface for event providers for new tradable dates
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Called each time there is a new tradable day
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New corporate event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,System.DateTime)">
            <summary>
            Initializes the event provider instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier">
            <summary>
            Interface which will provide an event handler
            who will be fired with each new tradable day
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier.NewTradableDate">
            <summary>
            Event fired when there is a new tradable date
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator">
            <summary>
            Auxiliary data enumerator that will trigger new tradable dates event accordingly
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider[],System.DateTime,QuantConnect.ITimeProvider,QuantConnect.Securities.SecurityCache)">
            <summary>
            Creates a new instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="tradableDateEventProviders">The tradable dates event providers</param>
            <param name="startTime">Start date for the data request</param>
            <param name="timeProvider">The time provider to use</param>
            <param name="securityCache">The security cache</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.MoveNext">
            <summary>
            Moves the LiveAuxiliaryDataEnumerator to the next item
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.TryCreate(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.ITimeProvider,QuantConnect.Securities.SecurityCache,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,System.DateTime,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}@)">
            <summary>
            Helper method to create a new instance.
            Knows which security types should create one and determines the appropriate delisting event provider to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator">
            <summary>
            Represents an enumerator capable of synchronizing live equity data enumerators in time.
            This assumes that all enumerators have data time stamped in the same time zone.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.#ctor(QuantConnect.ITimeProvider,NodaTime.DateTimeZone,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.List{System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator"/> class
            </summary>
            <param name="timeProvider">The source of time used to gauge when this enumerator should emit extra bars when null data is returned from the source enumerator</param>
            <param name="exchangeTimeZone">The time zone the raw data is time stamped in</param>
            <param name="tradeBarAggregator">The trade bar aggregator enumerator</param>
            <param name="auxDataEnumerators">The auxiliary data enumerators</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns> true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>The element in the collection at the current position of the enumerator.</returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>The current element in the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataSynchronizingEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveDelistingEventProvider">
            <summary>
            Delisting event provider implementation which will source the delisting date based on new map files
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveDelistingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for delistings
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New delisting event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveDividendEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> events
            </summary>
            <remarks>Only special behavior is that it will refresh factor file on each new tradable date event</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveDividendEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for dividends and returns them
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New Dividend event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator">
            <summary>
            An implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> that uses an <see cref="T:QuantConnect.ITimeProvider"/>
            to determine if a fill forward bar needs to be emitted
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.#ctor(QuantConnect.ITimeProvider,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,QuantConnect.Resolution,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator"/> class that accepts
            a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
            and changing as the enumeration progresses
            </summary>
            <param name="timeProvider">The source of time used to gauage when this enumerator should emit extra bars when
            null data is returned from the source enumerator</param>
            <param name="enumerator">The source enumerator to be filled forward</param>
            <param name="exchange">The exchange used to determine when to insert fill forward data</param>
            <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
            <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
            <param name="subscriptionEndTime">The end time of the subscription, once passing this date the enumerator will stop</param>
            <param name="dataResolution">The source enumerator's data resolution</param>
            <param name="dataTimeZone">Time zone of the underlying source data</param>
            <param name="dailyStrictEndTimeEnabled">True if daily strict end times are enabled</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
            <summary>
            Determines whether or not fill forward is required, and if true, will produce the new fill forward data
            </summary>
            <param name="fillForwardResolution"></param>
            <param name="previous">The last piece of data emitted by this enumerator</param>
            <param name="next">The next piece of data on the source enumerator, this may be null</param>
            <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
            <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.GetMaximumDataTimeout(QuantConnect.Resolution)">
            <summary>
            Helper method to know how much we should wait before fill forwarding a bar in live trading
            </summary>
            <remarks>This allows us to create bars taking into account the market auction close and open official prices. Also it will
            allow data providers which might have some delay on creating the bars on their end, to be consumed correctly, when available, by Lean</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveMappingEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> events
            </summary>
            <remarks>Only special behavior is that it will refresh map file on each new tradable date event</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveMappingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for new mappings
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSplitEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> events
            </summary>
            <remarks>Only special behavior is that it will refresh factor file on each new tradable date event</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSplitEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for dividends and returns them
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New Dividend event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator">
            <summary>
            Enumerator that will subscribe through the provided data queue handler and refresh the subscription if any mapping occurs
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.Current">
            <summary>
            The current data object instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            The current data object instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IDataQueueHandler,System.EventHandler,System.Func{QuantConnect.Data.SubscriptionDataConfig,System.Boolean})">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveSubscriptionEnumerator.Dispose">
            <summary>
            Disposes of the used enumerators
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.Config">
            <summary>
            The associated configuration
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.MapFile">
            <summary>
            The current instance being used
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for new mappings
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New mapping event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.InitializeMapFile">
            <summary>
            Initializes the map file to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.NewDataAvailableEventArgs">
            <summary>
            Event args for when a new data point is ready to be emitted
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.NewDataAvailableEventArgs.DataPoint">
            <summary>
            The new data point
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator">
            <summary>
            This enumerator will update the <see cref="P:QuantConnect.Data.SubscriptionDataConfig.PriceScaleFactor"/> when required
            and adjust the raw <see cref="T:QuantConnect.Data.BaseData"/> prices based on the provided <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>.
            Assumes the prices of the provided <see cref="T:System.Collections.IEnumerator"/> are in raw mode.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Explicit interface implementation for <see cref="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Current"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Current">
            <summary>
            Last read <see cref="T:QuantConnect.Data.BaseData"/> object from this type and source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,System.Boolean,System.Nullable{System.DateTime})">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator"/>.
            </summary>
            <param name="rawDataEnumerator">The underlying raw data enumerator</param>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to enumerate for.
            Will determine the <see cref="T:QuantConnect.DataNormalizationMode"/> to use.</param>
            <param name="factorFileProvider">The <see cref="T:QuantConnect.Interfaces.IFactorFileProvider"/> instance to use</param>
            <param name="liveMode">True, is this is a live mode data stream</param>
            <param name="endDate">The enumerator end date</param>
            <remarks>
            For <see cref="F:QuantConnect.DataNormalizationMode.ScaledRaw"/> normalization mode,
            the prices are scaled to the prices on the <paramref name="endDate"/>
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Dispose">
            <summary>
            Dispose of the underlying enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            True if the enumerator was successfully advanced to the next element;
            False if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator">
            <summary>
            The QuoteBarFillForwardEnumerator wraps an existing base data enumerator
            If the current QuoteBar has null Bid and/or Ask bars, it copies them from the previous QuoteBar
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> class
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1">
            <summary>
            Provides augmentation of how often an enumerator can be called. Time is measured using
            an <see cref="T:QuantConnect.ITimeProvider"/> instance and calls to the underlying enumerator are limited
            to a minimum time between each call.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},QuantConnect.ITimeProvider,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1"/> class
            </summary>
            <param name="enumerator">The underlying enumerator to place rate limits on</param>
            <param name="timeProvider">Time provider used for determing the time between calls</param>
            <param name="minimumTimeBetweenCalls">The minimum time allowed between calls to the underlying enumerator</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that will
            always return true via MoveNext.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1"/> class
            </summary>
            <param name="enumeratorFactory">Enumerator factory used to regenerate the underlying
            enumerator when it ends</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that relies on "consolidated" data
            </summary>
            <typeparam name="T">The item type yielded by the enumerator</typeparam>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.#ctor(QuantConnect.Data.Consolidators.IDataConsolidator,NodaTime.DateTimeZone,QuantConnect.ITimeProvider,System.EventHandler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1"/> class
            </summary>
            <param name="consolidator">Consolidator taking BaseData updates and firing events containing new 'consolidated' data</param>
            <param name="timeZone">The time zone the raw data is time stamped in</param>
            <param name="timeProvider">The time provider instance used to determine when bars are completed and can be emitted</param>
            <param name="newDataAvailableHandler">The event handler for a new available data point</param>
            <param name="isPeriodBased">The consolidator is period based, this will enable scanning on <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.MoveNext"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Update(`0)">
            <summary>
            Updates the consolidator
            </summary>
            <param name="data">The data to consolidate</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Enqueue(`0)">
            <summary>
            Enqueues the new data into this enumerator
            </summary>
            <param name="data">The data to be enqueued</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator">
            <summary>
            This enumerator will filter out data of the underlying enumerator based on a provided schedule.
            Will respect the schedule above the data, meaning will let older data through if the underlying provides none for the schedule date
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.Current">
            <summary>
            The current data point
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerable{System.DateTime},QuantConnect.ITimeProvider,NodaTime.DateTimeZone,System.DateTime)">
            <summary>
            Creates a new instance
            </summary>
            <param name="underlyingEnumerator">The underlying enumerator to filter</param>
            <param name="scheduledTimes">The scheduled times to emit new data points</param>
            <param name="frontierTimeProvider"></param>
            <param name="scheduleTimeZone"></param>
            <param name="startTime">the underlying request start time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns> True if the enumerator was successfully advanced to the next element;
            false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.Reset">
            <summary>
            Resets the underlying enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.Dispose">
            <summary>
            Disposes of the underlying enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScheduledEnumerator.GetUtcNow">
            <summary>
            Available in live trading only, in backtesting frontier is driven and sycned already by the data itself
            so we can't hold data here based on it
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Split"/> events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.FactorFile">
            <summary>
            The current instance being used
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.Config">
            <summary>
            The associated configuration
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IMapFileProvider,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">The factor file provider to use</param>
            <param name="mapFileProvider">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> provider to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for new splits
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New split event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.InitializeFactorFile">
            <summary>
            Initializes the factor file to use
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator">
            <summary>
            Enumerator that will handle adjusting daily strict end times if appropriate
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator.Current">
            <summary>
            Current value of the enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchangeHours,System.DateTime)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator.MoveNext">
            <summary>
            Move to the next date
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.StrictDailyEndTimesEnumerator.Dispose">
            <summary>
            Dispose the enumerator
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> which wraps an existing <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>Using this class is important, versus directly yielding, because we setup the <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Dispose"/> chain</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SecurityExchangeHours,QuantConnect.TimeZoneOffsetProvider,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="exchangeHours">The security's exchange hours</param>
            <param name="offsetProvider">The subscription's time zone offset provider</param>
            <param name="enumerator">The underlying data enumerator</param>
            <param name="isUniverse">The subscription is a universe subscription</param>
            <returns>A subscription data enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element;
            False if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator">
            <summary>
            Implements a wrapper around a base data enumerator to provide a final filtering step
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError">
            <summary>
            Fired when there's an error executing a user's data filter
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.WrapForDataFeed(QuantConnect.Lean.Engine.Results.IResultHandler,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime,System.Boolean,System.Boolean,QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Convenience method to wrap the enumerator and attach the data filter event to log and alery users of errors
            </summary>
            <param name="resultHandler">Result handler reference used to send errors</param>
            <param name="enumerator">The source enumerator to be wrapped</param>
            <param name="security">The security who's data is being enumerated</param>
            <param name="endTime">The end time of the subscription</param>
            <param name="extendedMarketHours">True if extended market hours are enabled</param>
            <param name="liveMode">True if live mode</param>
            <param name="securityExchangeHours">The security exchange hours instance to use</param>
            <returns>A new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator"/> class that has had it's <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError"/>
            event subscribed to to send errors to the result handler</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime,System.Boolean,System.Boolean,QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator"/> class
            </summary>
            <param name="enumerator">The source enumerator to be wrapped</param>
            <param name="security">The security containing an exchange and data filter</param>
            <param name="endTime">The end time of the subscription</param>
            <param name="extendedMarketHours">True if extended market hours are enabled</param>
            <param name="liveMode">True if live mode</param>
            <param name="securityExchangeHours">The security exchange hours instance to use</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.OnDataFilterError(System.Exception)">
            <summary>
            Event invocated for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError"/> event
            </summary>
            <param name="exception">The exception that was thrown when trying to perform data filtering</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator">
            <summary>
            Represents an enumerator capable of synchronizing other base data enumerators in time.
            This assumes that all enumerators have data time stamped in the same time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.IEnumerator})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingBaseDataEnumerator.GetInstanceTime(QuantConnect.Data.BaseData)">
            <summary>
            Gets the Timestamp for the data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1">
            <summary>
            Represents an enumerator capable of synchronizing other enumerators of type T in time.
            This assumes that all enumerators have data time stamped in the same time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.GetInstanceTime(`0)">
            <summary>
            Gets the Timestamp for the data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
            <remark>The type of data we want, for example, <see cref="T:QuantConnect.Data.BaseData"/> or <see cref="T:QuantConnect.Data.Slice"/>, ect...</remark>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
            <remark>The type of data we want, for example, <see cref="T:QuantConnect.Data.BaseData"/> or <see cref="T:QuantConnect.Data.Slice"/>, ect...</remark>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.GetSynchronizedEnumerator(System.Collections.Generic.IEnumerator{`0}[])">
            <summary>
            Synchronization system for the enumerator:
            </summary>
            <param name="enumerators"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator`1.GetBruteForceMethod(System.Collections.Generic.IEnumerator{`0}[])">
            <summary>
            Brute force implementation for synchronizing the enumerator.
            Will remove enumerators returning false to the call to MoveNext.
            Will not remove enumerators with Current Null returning true to the call to MoveNext
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator">
            <summary>
            Represents an enumerator capable of synchronizing other slice enumerators in time.
            This assumes that all enumerators have data time stamped in the same time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.Slice}[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.IEnumerator})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingSliceEnumerator.GetInstanceTime(QuantConnect.Data.Slice)">
            <summary>
            Gets the Timestamp for the data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed">
            <summary>
            Historical datafeed stream reader for processing files on a local disk.
            </summary>
            <remarks>Filesystem datafeeds are incredibly fast</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.IsActive">
            <summary>
            Flag indicating the hander thread is completely finished and ready to dispose.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Nullable{QuantConnect.Resolution})">
            <summary>
            Creates a file based data enumerator for the given subscription request
            </summary>
            <remarks>Protected so it can be used by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed"/> to warmup requests</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateUniverseEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Nullable{QuantConnect.Resolution},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},System.Nullable{QuantConnect.Resolution})">
            <summary>
            Creates a universe enumerator from the Subscription request, the underlying enumerator func and the fill forward resolution (in some cases)
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.AddScheduleWrapper(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.ITimeProvider)">
            <summary>
            Returns a scheduled enumerator from the given arguments. It can also return the given underlying enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.TryAppendUnderlyingEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Nullable{QuantConnect.Resolution},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},System.Nullable{QuantConnect.Resolution})">
            <summary>
            If required will add a new enumerator for the underlying symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Exit">
            <summary>
            Send an exit signal to the thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.ConfigureEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Boolean,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Nullable{QuantConnect.Resolution})">
            <summary>
            Configure the enumerator with aggregation/fill-forward/filter behaviors. Returns new instance if re-configured
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.TryAddFillForwardEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Boolean,System.Nullable{QuantConnect.Resolution})">
            <summary>
            Will add a fill forward enumerator if requested
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.FillForwardResolutionChangedEvent">
            <summary>
            Helper class for fill forward resolution change events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FillForwardResolutionChangedEvent.Old">
            <summary>
            The old fill forward time span
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FillForwardResolutionChangedEvent.New">
            <summary>
            The new fill forward time span
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed">
            <summary>
            Datafeed interface for creating custom datafeed sources.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.IsActive">
            <summary>
            Public flag indicator that the thread is still busy.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Exit">
            <summary>
            External controller calls to signal a terminate of the thread.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager">
            <summary>
            DataFeedSubscriptionManager interface will manage the subscriptions for the Data Feed
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.SubscriptionAdded">
            <summary>
            Event fired when a new subscription is added
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.SubscriptionRemoved">
            <summary>
            Event fired when an existing subscription is removed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.DataFeedSubscriptions">
            <summary>
            Gets the data feed subscription collection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>, if it exists
            </summary>
            <param name="configuration">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> of the subscription to remove</param>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>.
            Default value, null, will remove all universes</param>
            <returns>True if the subscription was successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> to provide data for the specified security.
            </summary>
            <param name="request">Defines the <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to be added</param>
            <returns>True if the subscription was created and added successfully, false otherwise</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider">
            <summary>
            Reduced interface which exposes required <see cref="T:QuantConnect.ITimeProvider"/> for <see cref="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed"/> implementations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider.FrontierTimeProvider">
            <summary>
            Time provider which returns current UTC frontier time
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataManager">
            <summary>
            IDataManager is the engines view of the Data Manager.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader">
            <summary>
            This <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> implementation supports
            the <see cref="F:QuantConnect.Data.FileFormat.Index"/> and <see cref="T:QuantConnect.Data.IndexedBaseData"/> types.
            Handles the layer of indirection for the index data source and forwards
            the target source to the corresponding <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Interfaces.IDataProvider,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Creates a new instance of this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager">
            <summary>
            Class in charge of handling Leans internal subscriptions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.Added">
            <summary>
            Event fired when a new internal subscription request is to be added
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.Removed">
            <summary>
            Event fired when an existing internal subscription should be removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.#ctor(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Resolution)">
            <summary>
            Creates a new instances
            </summary>
            <param name="algorithm">The associated algorithm</param>
            <param name="resolution">The resolution to use for the internal subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.AddedSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Notifies about a removed subscription request
            </summary>
            <param name="request">The removed subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.RemovedSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Notifies about an added subscription request
            </summary>
            <param name="request">The added subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.PreFilter(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            True for for live trading, non internal, non universe subscriptions, non custom data subscriptions
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs">
            <summary>
            Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Source">
            <summary>
            Gets the source that was considered invalid
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Exception">
            <summary>
            Gets the exception that was encountered
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.#ctor(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs"/> class
            </summary>
            <param name="source">The source that was considered invalid</param>
            <param name="exception">The exception that was encountered</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader">
            <summary>
            Represents a type responsible for accepting an input <see cref="T:QuantConnect.Data.SubscriptionDataSource"/>
            and returning an enumerable of the source's <see cref="T:QuantConnect.Data.BaseData"/>
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer">
            <summary>
            Provides the ability to synchronize subscriptions into time slices
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer.SubscriptionFinished">
            <summary>
            Event fired when a subscription is finished
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer.Sync(System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription},System.Threading.CancellationToken)">
            <summary>
            Syncs the specified subscriptions. The frontier time used for synchronization is
            managed internally and dependent upon previous synchronization operations.
            </summary>
            <param name="subscriptions">The subscriptions to sync</param>
            <param name="cancellationToken">The cancellation token to stop enumeration</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer">
            <summary>
            Interface which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that fetches the list of contracts
            from an external source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveFutureChainProvider.#ctor(QuantConnect.Interfaces.IDataCacheProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="dataCacheProvider">The data cache provider instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that fetches the list of contracts
            from the Options Clearing Corporation (OCC) website
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.#cctor">
            <summary>
            Static constructor for the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Interfaces.IMapFileProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="dataCacheProvider">The data cache provider instance to use</param>
            <param name="mapFileProvider">The map file provider instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the option chain associated with the underlying Symbol
            </summary>
            <param name="symbol">The option or the underlying symbol to get the option chain for.
            Providing the option allows targetting an option ticker different than the default e.g. SPXW</param>
            <param name="date">The date to ask for the option contract list for</param>
            <returns>Option chain</returns>
            <exception cref="T:System.ArgumentException">Option underlying Symbol is not Future or Equity</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.GetEquityIndexOptionContractList(QuantConnect.Symbol,System.String)">
            <summary>
            Gets the list of option contracts for a given underlying equity symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="expectedOptionTicker">The expected option ticker</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.FindOptionContracts(QuantConnect.Symbol,System.String)">
            <summary>
            Retrieve the list of option contracts for an underlying symbol from the OCC website
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer">
            <summary>
            Implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/> interface which provides the mechanism to stream live data to the algorithm
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.BatchingDelay">
            <summary>
            Consumer batching timeout in ms
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Initializes the instance of the Synchronizer class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.Dispose">
            <summary>
            Free resources
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.GetTimeProvider">
            <summary>
            Gets the <see cref="T:QuantConnect.ITimeProvider"/> to use. By default this will load the
            <see cref="T:QuantConnect.RealTimeProvider"/> for live mode, else <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider"/>
            </summary>
            <returns>The <see cref="T:QuantConnect.ITimeProvider"/> to use</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.PostInitialize">
            <summary>
            Performs additional initialization steps after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.GetPulseDueTime(System.DateTime)">
            <summary>
            Will return the amount of milliseconds that are missing for the next time pulse
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.OnSubscriptionNewDataAvailable(System.Object,System.EventArgs)">
            <summary>
            Trigger new data event
            </summary>
            <param name="sender">Sender of the event</param>
            <param name="args">Event information</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTimeProvider">
            <summary>
            Live time provide which supports an initial warmup period using the given time provider <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider"/>, used by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTimeProvider.#ctor(QuantConnect.ITimeProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="realTime">Real time provider</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTimeProvider.Initialize(QuantConnect.ITimeProvider)">
            <summary>
            Fully initializes this instance providing the initial warmup time provider to use
            </summary>
            <param name="warmupTimeProvider">The warmup provider to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed"/> that is designed to deal with
            live, remote data sources
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.IsActive">
            <summary>
            Public flag indicator that the thread is still busy.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Exit">
            <summary>
            External controller calls to signal a terminate of the thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetDataQueueHandler">
            <summary>
            Gets the <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> to use by default <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataQueueHandlerManager"/>
            </summary>
            <remarks>Useful for testing</remarks>
            <returns>The loaded <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetBaseDataExchange">
            <summary>
            Gets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange"/> to use
            </summary>
            <remarks>Useful for testing</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateDataSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription for the specified security
            </summary>
            <param name="request">The subscription request</param>
            <returns>A new subscription instance of the specified security</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.IsExpired(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Helper method to determine if the symbol associated with the requested configuration is expired or not
            </summary>
            <remarks>This is useful during warmup where we can be requested to add some already expired asset. We want to skip sending it
            to our live <see cref="F:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed._dataQueueHandler"/> instance to avoid explosions. But we do want to add warmup enumerators</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateUniverseSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription for universe selection
            </summary>
            <param name="request">The subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetWarmupEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Build and apply the warmup enumerators when required
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetFileBasedWarmupEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.LastPointTracker)">
            <summary>
            File based warmup enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetHistoryWarmupEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.LastPointTracker)">
            <summary>
            History based warmup enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetConfiguredFrontierAwareEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.TimeZoneOffsetProvider,System.Func{System.DateTime,System.Boolean})">
            <summary>
            Will wrap the provided enumerator with a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator"/>
            using a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider"/> that will advance time based on the provided
            function
            </summary>
            <remarks>Won't advance time if now.Hour is bigger or equal than 23pm, less or equal than 5am or Saturday.
            This is done to prevent universe selection occurring in those hours so that the subscription changes
            are handled correctly.</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler">
            <summary>
            Overrides methods of the base data exchange implementation
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.ITimeProvider"/> that can be
            manually advanced through time
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider"/>
            </summary>
            <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)"/>,
            leave null for the default of <see cref="F:QuantConnect.TimeZones.Utc"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(System.DateTime,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider"/> class
            </summary>
            <param name="currentTime">The current time in the specified time zone, if the time zone is
            null then the time is interpreted as being in <see cref="F:QuantConnect.TimeZones.Utc"/></param>
            <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)"/>,
            leave null for the default of <see cref="F:QuantConnect.TimeZones.Utc"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTimeUtc(System.DateTime)">
            <summary>
            Sets the current time interpreting the specified time as a UTC time
            </summary>
            <param name="time">The current time in UTC</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)">
            <summary>
            Sets the current time interpeting the specified time as a local time
            using the time zone used at instatiation.
            </summary>
            <param name="time">The local time to set the current time time, will be
            converted into UTC</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.Advance(System.TimeSpan)">
            <summary>
            Advances the current time by the specified span
            </summary>
            <param name="span">The amount of time to advance the current time by</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.AdvanceSeconds(System.Double)">
            <summary>
            Advances the current time by the specified number of seconds
            </summary>
            <param name="seconds">The number of seconds to advance the current time by</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed">
            <summary>
            Null data feed implementation. <seealso cref="T:QuantConnect.Lean.Engine.DataFeeds.DataManager"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.ShouldThrow">
            <summary>
            Allows specifying if this implementation should throw always or not
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.IsActive">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.Exit">
            <inheritdoc />
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager">
            <summary>
            Helper class used to managed pending security removals <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.PendingRemovals">
            <summary>
            Current pending removals
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.#ctor(QuantConnect.Securities.IOrderProvider)">
            <summary>
            Create a new instance
            </summary>
            <param name="orderProvider">The order provider used to determine if it is safe to remove a security</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.IsSafeToRemove(QuantConnect.Securities.Security,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Determines if we can safely remove the security member from a universe.
            We must ensure that we have zero holdings, no open orders, and no existing portfolio targets
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.TryRemoveMember(QuantConnect.Securities.Security,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Will determine if the <see cref="T:QuantConnect.Securities.Security"/> can be removed.
            If it can be removed will add it to <see cref="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.PendingRemovals"/>
            </summary>
            <param name="member">The security to remove</param>
            <param name="universe">The universe which the security is a member of</param>
            <returns>The member to remove</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.CheckPendingRemovals(System.Collections.Generic.HashSet{QuantConnect.Symbol},QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Will check pending security removals
            </summary>
            <param name="selectedSymbols">Currently selected symbols</param>
            <param name="currentUniverse">Current universe</param>
            <returns>The members to be removed</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember">
            <summary>
            Helper class used to report removed universe members
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember.Universe">
            <summary>
            Universe the security was removed from
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember.Security">
            <summary>
            Security that is removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember.#ctor(QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Securities.Security)">
            <summary>
            Initialize a new instance of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember"/>
            </summary>
            <param name="universe"><see cref="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember.Universe"/> the security was removed from</param>
            <param name="security"><see cref="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember.Security"/> that is removed</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData">
            <summary>
            Store data both raw and adjusted and the time at which it should be synchronized
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.DataNormalizationMode,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData"/> class
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="rawData">The base data</param>
            <param name="normalizedData">The normalized calculated based on raw data</param>
            <param name="normalizationMode">Specifies how data is normalized</param>
            <param name="emitTimeUtc">The emit time for the data</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider">
            <summary>
            Will generate time steps around the desired <see cref="T:QuantConnect.ITimeProvider"/>
            Provided step evaluator should return true when the next time step
            is valid and time can advance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider.#ctor(QuantConnect.ITimeProvider,System.Func{System.DateTime,System.Boolean})">
            <summary>
            Creates a new instance
            </summary>
            <param name="underlyingTimeProvider">The timer provider instance to wrap</param>
            <param name="customStepEvaluator">Function to evaluate whether or not
            to advance time. Should return true if provided <see cref="T:System.DateTime"/> is a
            valid new next time. False will avoid time advancing</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider.GetUtcNow">
            <summary>
            Gets the current utc time step
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue">
            <summary>
            Live Data Queue is the cut out implementation of how to bind a custom live data source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Subscribe(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Desktop/Local doesn't support live data from this handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Unsubscribe(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Desktop/Local doesn't support live data from this handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.SetJob(QuantConnect.Packets.LiveNodePacket)">
            <summary>
            Sets the job we're subscribing for
            </summary>
            <param name="job">Job we're subscribing for</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.IsConnected">
            <summary>
            Returns whether the data provider is connected
            </summary>
            <returns>true if the data provider is connected</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue">
            <summary>
            This is an implementation of <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> used for testing. <see cref="T:QuantConnect.Lean.Engine.HistoricalData.FakeHistoryProvider"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue"/> class to randomly emit data for each symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.#ctor(QuantConnect.Data.IDataAggregator,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue"/> class to randomly emit data for each symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Subscribe(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Subscribe to the specified configuration
            </summary>
            <param name="dataConfig">defines the parameters to subscribe to a data feed</param>
            <param name="newDataAvailableHandler">handler to be fired on new data available</param>
            <returns>The new enumerator for this subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.SetJob(QuantConnect.Packets.LiveNodePacket)">
            <summary>
            Sets the job we're subscribing for
            </summary>
            <param name="job">Job we're subscribing for</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Unsubscribe(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Removes the specified configuration
            </summary>
            <param name="dataConfig">Subscription config to be removed</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.IsConnected">
            <summary>
            Returns whether the data provider is connected
            </summary>
            <returns>true if the data provider is connected</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.PopulateQueue">
            <summary>
            Pumps a bunch of ticks into the queue
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.LookupSymbols(QuantConnect.Symbol,System.Boolean,System.String)">
            <summary>
            Method returns a collection of Symbols that are available at the data source.
            </summary>
            <param name="symbol">Symbol to lookup</param>
            <param name="includeExpired">Include expired contracts</param>
            <param name="securityCurrency">Expected security currency(if any)</param>
            <returns>Enumerable of Symbols, that are associated with the provided Symbol</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.CanPerformSelection">
            <summary>
            Checks if the FakeDataQueue can perform selection
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs">
            <summary>
            Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError"/> event.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Line">
            <summary>
            Gets the line that caused the error
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Exception">
            <summary>
            Gets the exception that was caught
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs"/> class
            </summary>
            <param name="line">The line that caused the error</param>
            <param name="exception">The exception that was caught during the read</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService">
            <summary>
            Allows to setup a real time scheduled event, internally using a <see cref="T:System.Threading.Thread"/>,
            that is guaranteed to trigger at or after the requested time, never before.
            </summary>
            <remarks>This class is of value because <see cref="T:System.Threading.Timer"/> could fire the
            event before time.</remarks>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.NewEvent">
            <summary>
            Event fired when the scheduled time is past
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.#ctor(QuantConnect.ITimeProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeProvider">The time provider to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.ScheduleEvent(System.TimeSpan,System.DateTime)">
            <summary>
            Schedules a new event
            </summary>
            <param name="dueTime">The desired due time</param>
            <param name="utcNow">Current utc time</param>
            <remarks>Scheduling a new event will try to disable previous scheduled event,
            but it is not guaranteed.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.Dispose">
            <summary>
            Disposes of the underlying <see cref="T:System.Threading.Timer"/> instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider">
            <summary>
            Default implementation of the <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/>
            Does not cache data.  If the data is a zip, the first entry is returned
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.IsDataEphemeral">
            <summary>
            Property indicating the data is temporary in nature and should not be cached.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.#ctor(QuantConnect.Interfaces.IDataProvider,System.Boolean)">
            <summary>
            Constructor that takes the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> to be used to retrieve data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Fetch(System.String)">
            <summary>
            Fetch data from the cache
            </summary>
            <param name="key">A string representing the key of the cached data</param>
            <returns>An <see cref="T:System.IO.Stream"/> of the cached data</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Store(System.String,System.Byte[])">
            <summary>
            Not implemented
            </summary>
            <param name="key">The source of the data, used as a key to retrieve data in the cache</param>
            <param name="data">The data to cache as a byte array</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.GetZipEntries(System.String)">
            <summary>
            Returns a list of zip entries in a provided zip file
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Subscription">
            <summary>
            Represents the data required for a data feed to process a single subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.SubscriptionRequests">
            <summary>
            The subcription requests associated with this subscription
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Subscription.NewDataAvailable">
            <summary>
            Event fired when a new data point is available
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Universes">
            <summary>
            Gets the universe for this subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Security">
            <summary>
            Gets the security this subscription points to
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Configuration">
            <summary>
            Gets the configuration for this subscritions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.TimeZone">
            <summary>
            Gets the exchange time zone associated with this subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.OffsetProvider">
            <summary>
            Gets the offset provider for time zone conversions to and from the data's local time
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.RealtimePrice">
            <summary>
            Gets the most current value from the subscription source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.EndOfStream">
            <summary>
            Gets true if this subscription is finished, false otherwise
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.IsUniverseSelectionSubscription">
            <summary>
            Gets true if this subscription is used in universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcStartTime">
            <summary>
            Gets the start time of this subscription in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcEndTime">
            <summary>
            Gets the end time of this subscription in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.RemovedFromUniverse">
            <summary>
            Gets whether or not this subscription has been removed from its parent universe
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Lean.Engine.DataFeeds.SubscriptionData},QuantConnect.TimeZoneOffsetProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> class with a universe
            </summary>
            <param name="subscriptionRequest">Specified for universe subscriptions</param>
            <param name="enumerator">The subscription's data source</param>
            <param name="timeZoneOffsetProvider">The offset provider used to convert data local times to utc</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.AddSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> for this subscription
            </summary>
            <param name="subscriptionRequest">The <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.RemoveSubscriptionRequest(QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes one or all <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> from this subscription
            </summary>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/>.
            Default value, null, will remove all universes</param>
            <returns>True, if the subscription is empty and ready to be removed</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.MarkAsRemovedFromUniverse">
            <summary>
            Mark this subscription as having been removed from the universe.
            Data for this time step will be discarded.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object. </param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.OnNewDataAvailable">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Subscription.NewDataAvailable"/> event
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection">
            <summary>
            Provides a collection for holding subscriptions.
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.FillForwardResolutionChanged">
            <summary>
            Event fired when the fill forward resolution changes
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.Contains(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Checks the collection for the specified subscription configuration
            </summary>
            <param name="configuration">The subscription configuration to check for</param>
            <returns>True if a subscription with the specified configuration is found in this collection, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryAdd(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Attempts to add the specified subscription to the collection. If another subscription
            exists with the same configuration then it won't be added.
            </summary>
            <param name="subscription">The subscription to add</param>
            <returns>True if the subscription is successfully added, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryGetValue(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
            <summary>
            Attempts to retrieve the subscription with the specified configuration
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="subscription">The subscription matching the configuration, null if not found</param>
            <returns>True if the subscription is successfully retrieved, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryRemove(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
            <summary>
            Attempts to remove the subscription with the specified configuraton from the collection.
            </summary>
            <param name="configuration">The configuration of the subscription to remove</param>
            <param name="subscription">The removed subscription, null if not found.</param>
            <returns>True if the subscription is successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.UpdateAndGetFillForwardResolution(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets and updates the fill forward resolution by checking specified subscription configurations and
            selecting the smallest resoluton not equal to tick
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.FreezeFillForwardResolution(System.Boolean)">
            <summary>
            Will disable or enable fill forward resolution updates
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.ValidateFillForwardResolution(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Helper method to validate a configuration to be included in the fill forward calculation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.UpdateFillForwardResolution(QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.FillForwardResolutionOperation,QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets and updates the fill forward resolution by checking specified subscription configurations and
            selecting the smallest resoluton not equal to tick
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.SortSubscriptions">
            <summary>
            Sorts subscriptions so that equity subscriptions are enumerated before option
            securities to ensure the underlying data is available when we process the options data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData">
            <summary>
            Store data (either raw or adjusted) and the time at which it should be synchronized
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData._data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.EmitTimeUtc">
            <summary>
            Gets the UTC emit time for this data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.#ctor(QuantConnect.Data.BaseData,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> class
            </summary>
            <param name="data">The base data</param>
            <param name="emitTimeUtc">The emit time for the data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.Create(System.Boolean,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SecurityExchangeHours,QuantConnect.TimeZoneOffsetProvider,QuantConnect.Data.BaseData,QuantConnect.DataNormalizationMode,System.Nullable{System.Decimal})">
            <summary>
            Clones the data, computes the utc emit time and performs exchange round down behavior, storing the result in a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> instance
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="exchangeHours">The exchange hours of the security</param>
            <param name="offsetProvider">The subscription's offset provider</param>
            <param name="data">The data being emitted</param>
            <param name="normalizationMode">Specifies how data is normalized</param>
            <param name="factor">price scale factor</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> containing the specified data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader">
            <summary>
            Subscription data reader is a wrapper on the stream reader class to download, unpack and iterate over a data file.
            </summary>
            <remarks>The class accepts any subscription configuration and automatically makes it available to enumerate</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._config">
            Configuration of the data-reader:
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._hasScaleFactors">
            true if we can find a scale factor file for the security of the form: ..\Lean\Data\equity\market\factor_files\{SYMBOL}.csv
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected">
            <summary>
            Event fired when an invalid configuration has been detected
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited">
            <summary>
            Event fired when the numerical precision in the factor file has been limited
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited">
            <summary>
            Event fired when the start date has been limited
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed">
            <summary>
            Event fired when there was an error downloading a remote file
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected">
            <summary>
            Event fired when there was an error reading the data
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate">
            <summary>
            Event fired when there is a new tradable date
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Current">
            <summary>
            Last read BaseData object from this type and source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.System#Collections#IEnumerator#Current">
            <summary>
            Explicit Interface Implementation for Current
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.BaseDataRequest,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Subscription data reader takes a subscription request, loads the type, accepts the data source and enumerate on the results.
            </summary>
            <param name="config">Subscription configuration object</param>
            <param name="dataRequest">The data request</param>
            <param name="mapFileProvider">Used for resolving the correct map files</param>
            <param name="factorFileProvider">Used for getting factor files</param>
            <param name="dataCacheProvider">Used for caching files</param>
            <param name="dataProvider">The data provider to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Initialize">
            <summary>
            Initializes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/> instance
            </summary>
            <remarks>Should be called after all consumers of <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event are set,
            since it will produce events.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.UpdateDataEnumerator(System.Boolean)">
            <summary>
            Resolves the next enumerator to be used in <see cref="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext"/> and updates
            <see cref="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._subscriptionFactoryEnumerator"/>
            </summary>
            <returns>True, if the enumerator has been updated (even if updated to null)</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.TryGetNextDate(System.DateTime@)">
            <summary>
            Iterates the tradeable dates enumerator
            </summary>
            <param name="date">The next tradeable date</param>
            <returns>True if we got a new date from the enumerator, false if it's exhausted, or in live mode if we're already at today</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Dispose">
            <summary>
            Dispose of the Stream Reader and close out the source stream and file connections.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnInvalidConfigurationDetected(QuantConnect.InvalidConfigurationDetectedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnNumericalPrecisionLimited(QuantConnect.NumericalPrecisionLimitedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnStartDateLimited(QuantConnect.StartDateLimitedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnDownloadFailed(QuantConnect.DownloadFailedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnReaderErrorDetected(QuantConnect.ReaderErrorDetectedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnNewTradableDate(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader">
            <summary>
            Provides a factory method for creating <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.ForSource(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Data.BaseData,QuantConnect.Interfaces.IDataProvider,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> capable of handling the specified <paramref name="source"/>
            </summary>
            <param name="source">The subscription data source to create a factory for</param>
            <param name="dataCacheProvider">Used to cache data</param>
            <param name="config">The configuration of the subscription</param>
            <param name="date">The date to be processed</param>
            <param name="isLiveMode">True for live mode, false otherwise</param>
            <param name="factory">The base data instance factory</param>
            <param name="dataProvider">The data provider to use</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that can read the specified <paramref name="source"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.CheckRemoteFileCache">
            <summary>
            Creates cache directory if not existing and deletes old files from the cache
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider">
            <summary>
            A time provider which updates 'now' time based on the current data emit time of all subscriptions
            </summary>
            <remarks>This class is not thread safe but there is no need for it to be since it's only consumed by the
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.#ctor(System.DateTime,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Creates a new instance of the SubscriptionFrontierTimeProvider
            </summary>
            <param name="utcNow">Initial UTC now time</param>
            <param name="subscriptionManager">Subscription manager. Will be used to obtain current subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.UpdateCurrentTime">
            <summary>
            Sets the current time calculated as the minimum current data emit time of all the subscriptions.
            If there are no subscriptions current time will remain unchanged
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer">
            <summary>
            Provides the ability to synchronize subscriptions into time slices
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished">
            <summary>
            Event fired when a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> is finished
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.#ctor(QuantConnect.Lean.Engine.DataFeeds.UniverseSelection)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer"/> class
            </summary>
            <param name="universeSelection">The universe selection instance used to handle universe
            selection subscription output</param>
            <returns>A time slice for the specified frontier time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SetTimeProvider(QuantConnect.ITimeProvider)">
            <summary>
            Sets the time provider. If already set will throw.
            </summary>
            <param name="timeProvider">The time provider, used to obtain the current frontier UTC value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SetTimeSliceFactory(QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory)">
            <summary>
            Sets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory"/> instance to use
            </summary>
            <param name="timeSliceFactory">Used to create the new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.Sync(System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription},System.Threading.CancellationToken)">
            <summary>
            Syncs the specified subscriptions. The frontier time used for synchronization is
            managed internally and dependent upon previous synchronization operations.
            </summary>
            <param name="subscriptions">The subscriptions to sync</param>
            <param name="cancellationToken">The cancellation token to stop enumeration</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.OnSubscriptionFinished(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.GetUtcNow">
            <summary>
            Returns the current UTC frontier time
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils">
            <summary>
            Utilities related to data <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.Create(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Boolean)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> which will directly consume the provided enumerator
            </summary>
            <param name="request">The subscription data request</param>
            <param name="enumerator">The data enumerator stack</param>
            <returns>A new subscription instance ready to consume</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.CreateAndScheduleWorker(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Interfaces.IFactorFileProvider,System.Boolean,System.Boolean)">
            <summary>
            Setups a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> which will consume a blocking <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1"/>
            that will be feed by a worker task
            </summary>
            <param name="request">The subscription data request</param>
            <param name="enumerator">The data enumerator stack</param>
            <param name="factorFileProvider">The factor file provider</param>
            <param name="enablePriceScale">Enables price factoring</param>
            <returns>A new subscription instance ready to consume</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.GetEndedSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Return an ended subscription so it doesn't blow up at runtime on the data worker, this can happen if there's no tradable date
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Synchronizer">
            <summary>
            Implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/> interface which provides the mechanism to stream data to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.SubscriptionManager">
            <summary>
            The subscription manager
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.SubscriptionSynchronizer">
            <summary>
            The subscription synchronizer
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.TimeSliceFactory">
            <summary>
            The time slice factory
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.TimeProvider">
            <summary>
            Continuous UTC time provider, only valid for live trading see <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.FrontierTimeProvider">
            <summary>
            Time provider which returns current UTC frontier time
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Initializes the instance of the Synchronizer class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.PostInitialize">
            <summary>
            Performs additional initialization steps after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.GetTimeProvider">
            <summary>
            Gets the <see cref="T:QuantConnect.ITimeProvider"/> to use. By default this will load the
            <see cref="T:QuantConnect.RealTimeProvider"/> for live mode, else <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider"/>
            </summary>
            <returns>The <see cref="T:QuantConnect.ITimeProvider"/> to use</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Dispose">
            <summary>
            Free resources
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader">
            <summary>
            Provides an implementations of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that uses the
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            method to read lines of text from a <see cref="T:QuantConnect.Data.SubscriptionDataSource"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.Config">
            <summary>
            The requested subscription configuration
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError">
            <summary>
            Event fired when an exception is thrown during a call to
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataCacheProvider">This provider caches files if needed</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError"/> event
            </summary>
            <param name="line">The line that caused the exception</param>
            <param name="exception">The exception that was caught</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.SetCacheSize(System.Int32)">
            <summary>
            Set the cache size to use
            </summary>
            <remarks>How to size this cache: Take worst case scenario, BTCUSD hour, 60k QuoteBar entries, which are roughly 200 bytes in size -> 11 MB * CacheSize</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ClearCache">
            <summary>
            Will clear the data cache.
            Used for testing different time zones for the same data set and allow a clean fresh start for each backtest
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice">
            <summary>
            Represents a grouping of data emitted at a certain time.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.DataPointCount">
            <summary>
            Gets the count of data points in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Time">
            <summary>
            Gets the UTC time this data was emitted
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Data">
            <summary>
            Gets the data in the time slice
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Slice">
            <summary>
            Gets the <see cref="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Slice"/> that will be used as input for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecuritiesUpdateData">
            <summary>
            Gets the data used to update securities
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.ConsolidatorUpdateData">
            <summary>
            Gets the data used to update the consolidators
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.CustomData">
            <summary>
            Gets all the custom data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecurityChanges">
            <summary>
            Gets the changes to the data subscriptions as a result of universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.UniverseData">
            <summary>
            Gets the universe data generated this time step.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.IsTimePulse">
            <summary>
            True indicates this time slice is a time pulse for the algorithm containing no data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.#ctor(System.DateTime,System.Int32,QuantConnect.Data.Slice,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Interfaces.ISecurityPrice}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Data.SubscriptionDataConfig}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Interfaces.ISecurityPrice}},QuantConnect.Data.UniverseSelection.SecurityChanges,System.Collections.Generic.Dictionary{QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Data.UniverseSelection.BaseDataCollection},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> containing the specified data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory">
            <summary>
            Instance base class that will provide methods for creating new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeZone">The time zone required for computing algorithm and slice time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.CreateTimePulse(System.DateTime)">
            <summary>
            Creates a new empty <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> to be used as a time pulse
            </summary>
            <remarks>The objective of this method is to standardize the time pulse creation</remarks>
            <param name="utcDateTime">The UTC frontier date time</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> time pulse</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.Create(System.DateTime,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},QuantConnect.Data.UniverseSelection.SecurityChanges,System.Collections.Generic.Dictionary{QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Data.UniverseSelection.BaseDataCollection})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> for the specified time using the specified data
            </summary>
            <param name="utcDateTime">The UTC frontier date time</param>
            <param name="data">The data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/></param>
            <param name="changes">The new changes that are seen in this time slice as a result of universe selection</param>
            <param name="universeData"></param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> containing the specified data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader">
            <summary>
            Represents a stream reader capable of reading lines from disk
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The local file to be read</param>
            <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
            or to open the first zip entry found regardless of name</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The local file to be read</param>
            <param name="startingPosition">The position in the stream from which to start reading</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(Ionic.Zip.ZipFile,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="zipFile">The local zip archive to be read</param>
            <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
            or to open the first zip entry found regardless of name</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EntryFileNames">
            <summary>
            Returns the list of zip entries if local file stream reader is reading zip archive
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.LocalFile"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.Dispose">
            <summary>
            Disposes of the stream
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader">
            <summary>
            Represents a stream reader capable of reading lines from the object store
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IObjectStore,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader"/> class.
            </summary>
            <param name="objectStore">The <see cref="T:QuantConnect.Interfaces.IObjectStore"/> used to retrieve a stream of data</param>
            <param name="key">The object store key the data should be fetched from</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.LocalFile"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.ObjectStoreSubscriptionStreamReader.Dispose">
            <summary>
            Disposes of the stream
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader">
            <summary>
            Represents a stream reader capabable of downloading a remote file and then
            reading it from disk
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.LocalFileName">
            <summary>
            The local file name of the downloaded file
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The remote url to be downloaded via web client</param>
            <param name="downloadDirectory">The local directory and destination of the download</param>
            <param name="headers">Defines header values to add to the request</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.RemoteFile"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.Dispose">
            <summary>
            Disposes of the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.SetDownloadProvider(QuantConnect.Interfaces.IDownloadProvider)">
            <summary>
            Save reference to the download system.
            </summary>
            <param name="downloader">Downloader provider for the remote file fetching.</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader">
            <summary>
            Represents a stream reader capable of polling a rest client
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader"/> class.
            </summary>
            <param name="source">The source url to poll with a GET</param>
            <param name="headers">Defines header values to add to the request</param>
            <param name="isLiveMode">True for live mode, false otherwise</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.Rest"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.Dispose">
            <summary>
            This stream reader doesn't require disposal
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection">
            <summary>
            Provides methods for apply the results of universe selection to an algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.#ctor(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.ISecurityService,QuantConnect.Interfaces.IDataPermissionManager,QuantConnect.Interfaces.IDataProvider,QuantConnect.Resolution)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/> class
            </summary>
            <param name="algorithm">The algorithm to add securities to</param>
            <param name="securityService">The security service</param>
            <param name="dataPermissionManager">The data permissions manager</param>
            <param name="dataProvider">The data provider to use</param>
            <param name="internalConfigResolution">The resolution to use for internal configuration</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.SetDataManager(QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Sets the data manager
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.ApplyUniverseSelection(QuantConnect.Data.UniverseSelection.Universe,System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Applies universe selection the the data feed and algorithm
            </summary>
            <param name="universe">The universe to perform selection on</param>
            <param name="dateTimeUtc">The current date time in utc</param>
            <param name="universeData">The data provided to perform selection with</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.AddPendingInternalDataFeeds(System.DateTime)">
            <summary>
            Will add any pending internal currency subscriptions
            </summary>
            <param name="utcStart">The current date time in utc</param>
            <returns>Will return true if any subscription was added</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.EnsureCurrencyDataFeeds(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Checks the current subscriptions and adds necessary currency pair feeds to provide real time conversion data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.HandleDelisting(QuantConnect.Data.BaseData,System.Boolean)">
            <summary>
            Handles the delisting process of the given data symbol from the algorithm securities
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1">
            <summary>
            Transport type for algorithm update data. This is intended to provide a
            list of base data used to perform updates against the specified target
            </summary>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.ContainsFillForwardData">
            <summary>
            Flag indicating whether <see cref="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Data"/> contains any fill forward bar or not
            </summary>
            <remarks>This is useful for performance, it allows consumers to skip re enumerating the entire data
            list to filter any fill forward data</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Target">
            <summary>
            The target, such as a security or subscription data config
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Data">
            <summary>
            The data used to update the target
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.DataType">
            <summary>
            The type of data in the data list
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.IsInternalConfig">
            <summary>
            True if this update data corresponds to an internal subscription
            such as currency or security benchmark
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.#ctor(`0,System.Type,System.Collections.Generic.IReadOnlyList{QuantConnect.Data.BaseData},System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1"/> class
            </summary>
            <param name="target">The end consumer/user of the dat</param>
            <param name="dataType">The type of data in the list</param>
            <param name="data">The update data</param>
            <param name="isInternalConfig">True if this update data corresponds to an internal subscription
            such as currency or security benchmark</param>
            <param name="containsFillForwardData">True if this update data contains fill forward bars</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkScheduler">
            <summary>
            Base work scheduler abstraction
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkScheduler.WorkersCount">
            <summary>
            The quantity of workers to be used
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkScheduler.QueueWork(QuantConnect.Symbol,System.Func{System.Int32,System.Boolean},System.Func{System.Int32})">
            <summary>
            Add a new work item to the queue
            </summary>
            <param name="symbol">The symbol associated with this work</param>
            <param name="workFunc">The work function to run</param>
            <param name="weightFunc">The weight function.
            Work will be sorted in ascending order based on this weight</param>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue._workAvailableEvent">
            <summary>
            Event used to notify there is work ready to execute in this queue
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.ThreadPriority">
            <summary>
            Returns the thread priority to use for this work queue
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.WorkerThread(System.Collections.Concurrent.ConcurrentQueue{QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem},System.Threading.AutoResetEvent)">
            <summary>
            This is the worker thread loop.
            It will first try to take a work item from the new work queue else will check his own queue.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.Add(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Adds a new item to this work queue
            </summary>
            <param name="work">The work to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.AddSingleCall(System.Action)">
            <summary>
            Adds a new item to this work queue
            </summary>
            <param name="work">The work to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.Remove(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Removes an item from the work queue
            </summary>
            <param name="workItem">The work item to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkQueue.Get">
            <summary>
            Gets the next work item to process
            </summary>
            <returns>The work item to process, null if none available</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler">
            <summary>
            This singleton class will create a thread pool to processes work
            that will be prioritized based on it's weight
            </summary>
            <remarks>The threads in the pool will take ownership of the
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem"/> and not share it with another thread.
            This is required because the data enumerator stack yields, which state
            depends on the thread id</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.WorkBatchSize">
            <summary>
            This is the size of each work sprint
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.MaxWorkWeight">
            <summary>
            This is the maximum size a work item can weigh,
            if reached, it will be ignored and not executed until its less
            </summary>
            <remarks>This is useful to limit RAM and CPU usage</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.QueueWork(QuantConnect.Symbol,System.Func{System.Int32,System.Boolean},System.Func{System.Int32})">
            <summary>
            Add a new work item to the queue
            </summary>
            <param name="symbol">The symbol associated with this work</param>
            <param name="workFunc">The work function to run</param>
            <param name="weightFunc">The weight function.
            Work will be sorted in ascending order based on this weight</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.AddSingleCallForAll(System.Action)">
            <summary>
            Execute the given action in all workers once
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem">
            <summary>
            Class to represent a work item
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem._weightFunc">
            <summary>
            Function to determine weight of item
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Weight">
            <summary>
            The current weight
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Work">
            <summary>
            The work function to execute
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.#ctor(System.Func{System.Int32,System.Boolean},System.Func{System.Int32})">
            <summary>
            Creates a new instance
            </summary>
            <param name="work">The work function, takes an int, the amount of work to do
            and returns a bool, false if this work item is finished</param>
            <param name="weightFunc">The function used to determine the current weight</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.UpdateWeight">
            <summary>
            Updates the weight of this work item
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Compare(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem,QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Compares two work items based on their weights
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider">
            <summary>
            File provider implements optimized zip archives caching facility. Cache is thread safe.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.IsDataEphemeral">
            <summary>
            Property indicating the data is temporary in nature and should not be cached.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.#ctor(QuantConnect.Interfaces.IDataProvider,System.Boolean,System.Double)">
            <summary>
            Constructor that sets the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> used to retrieve data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Fetch(System.String)">
            <summary>
            Does not attempt to retrieve any data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Store(System.String,System.Byte[])">
            <summary>
            Store the data in the cache.
            </summary>
            <param name="key">The source of the data, used as a key to retrieve data in the cache</param>
            <param name="data">The data as a byte array</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.GetZipEntries(System.String)">
            <summary>
            Returns a list of zip entries in a provided zip file
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CleanCache">
            <summary>
            Remove items in the cache that are older than the cutoff date
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CreateEntryStream(QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile,System.String,System.String)">
            <summary>
            Create a stream of a specific ZipEntry
            </summary>
            <param name="zipFile">The zipFile containing the zipEntry</param>
            <param name="entryName">The name of the entry</param>
            <param name="fileName">The name of the zip file on disk</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the appropriate zip entry</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Cache(System.String,QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile@)">
            <summary>
            Cache a Zip
            </summary>
            <param name="filename">Zip to cache</param>
            <param name="cachedZip">The resulting CachedZipFile</param>
            <returns></returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile">
            <summary>
            Type for storing zipfile in cache
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile._zipFile">
            <summary>
            The ZipFile this object represents
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.EntryCache">
            <summary>
            Contains all entries of the zip file by filename
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Disposed">
            <summary>
            Returns if this cached zip file is disposed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.#ctor(System.IO.Stream,System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile"/>
            </summary>
            <param name="dataStream">Stream containing the zip file</param>
            <param name="utcNow">Current utc time</param>
            <param name="filePath">Path of the zip file</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Uncache(System.DateTime)">
            <summary>
            Method used to check if this object was created before a certain time
            </summary>
            <param name="date">DateTime which is compared to the DateTime this object was created</param>
            <returns>Bool indicating whether this object is older than the specified time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.WriteEntry(System.String,System.Byte[])">
            <summary>
            Write to this entry, will be updated on disk when uncached
            Meaning either when timer finishes or on dispose
            </summary>
            <param name="entryName">Entry to write this as</param>
            <param name="content">Content of the entry</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Refresh">
            <summary>
            We refresh our cache time when used to avoid it being clean up
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Dispose">
            <summary>
            Dispose of the ZipFile
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.ZipEntryCache">
            <summary>
            ZipEntry wrapper which handles flagging a modified entry
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that reads zip entry names
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataProvider">Used to fetch data</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Engine">
             <summary>
             LEAN ALGORITHMIC TRADING ENGINE: ENTRY POINT.
            
             The engine loads new tasks, create the algorithms and threads, and sends them
             to Algorithm Manager to be executed. It is the primary operating loop.
             </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.SystemHandlers">
            <summary>
            Gets the configured system handlers for this engine instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.AlgorithmHandlers">
            <summary>
            Gets the configured algorithm handlers for this engine instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.#ctor(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Engine"/> class using the specified handlers
            </summary>
            <param name="systemHandlers">The system handlers for controlling acquisition of jobs, messaging, and api calls</param>
            <param name="algorithmHandlers">The algorithm handlers for managing algorithm initialization, data, results, transaction, and real time events</param>
            <param name="liveMode">True when running in live mode, false otherwise</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.Run(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager,System.String,QuantConnect.Util.WorkerThread)">
            <summary>
            Runs a single backtest/live job from the job queue
            </summary>
            <param name="job">The algorithm job to be processed</param>
            <param name="manager">The algorithm manager instance</param>
            <param name="assemblyPath">The path to the algorithm's assembly</param>
            <param name="workerThread">The worker thread instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.HandleAlgorithmError(QuantConnect.Packets.AlgorithmNodePacket,System.Exception)">
            <summary>
            Handle an error in the algorithm.Run method.
            </summary>
            <param name="job">Job we're processing</param>
            <param name="err">Error from algorithm stack</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.GetHistoryProvider">
            <summary>
            Load the history provider from the Composer
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.SaveListOfTrades(QuantConnect.Securities.IOrderProvider,System.String)">
            <summary>
            Save a list of trades to disk for a given path
            </summary>
            <param name="transactions">Transactions list via an OrderProvider</param>
            <param name="csvFileName">File path to create</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.StaticInitializations">
            <summary>
            Initialize slow static variables
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> that relies on
            a brokerage connection to retrieve historical data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.SetBrokerage(QuantConnect.Interfaces.IBrokerage)">
            <summary>
            Sets the brokerage to be used for historical requests
            </summary>
            <param name="brokerage">The brokerage instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.FakeHistoryProvider">
            <summary>
            Provides FAKE implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> used for testing. <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.FakeHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.FakeHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.FakeHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> which
            acts as a wrapper to use multiple history providers together
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager._historyProviders">
            <summary>
            Collection of history providers being used
            </summary>
            <remarks>Protected for testing purposes</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager.SetBrokerage(QuantConnect.Interfaces.IBrokerage)">
            <summary>
            Sets the brokerage to be used for historical requests
            </summary>
            <param name="brokerage">The brokerage instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.HistoryProviderManager.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider">
            <summary>
            Implements a History provider that always return a IEnumerable of Slice with prices following a sine function
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.#ctor(QuantConnect.Securities.SecurityManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider"/> class
            </summary>
            <param name="securities">Collection of securities that a history request can return</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> that uses <see cref="T:QuantConnect.Data.BaseData"/>
            instances to retrieve historical data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.DataPermissionManager">
            <summary>
            Manager used to allow or deny access to a requested datasource for specific users
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.CreateSubscription(QuantConnect.Data.HistoryRequest)">
            <summary>
            Creates a subscription to process the request
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.GetIntradayDataEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.HistoryRequest)">
            <summary>
            Gets the intraday data enumerator if any
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.TimeBasedFilter">
            <summary>
            Internal helper class to filter data based on requested times
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider">
            <summary>
            Provides an abstract implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/>
            which provides synchronization of multiple history results
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.AlgorithmSettings">
            <summary>
            The algorithm settings instance to use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.CreateSliceEnumerableFromSubscriptions(System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.Subscription},NodaTime.DateTimeZone)">
            <summary>
            Enumerates the subscriptions into slices
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.CreateSubscription(QuantConnect.Data.HistoryRequest,System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData})">
            <summary>
            Creates a subscription to process the history request
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Initializer">
            <summary>
            Helper class to initialize a Lean engine
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Initializer.Start">
            <summary>
            Basic common Lean initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Initializer.GetSystemHandlers">
            <summary>
            Get and initializes System Handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Initializer.GetAlgorithmHandlers(System.Boolean)">
            <summary>
            Get and initializes Algorithm Handler
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers">
            <summary>
            Provides a container for the algorithm specific handlers
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Results">
            <summary>
            Gets the result handler used to communicate results from the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Setup">
            <summary>
            Gets the setup handler used to initialize the algorithm state
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataFeed">
            <summary>
            Gets the data feed handler used to provide data to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Transactions">
            <summary>
            Gets the transaction handler used to process orders from the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.RealTime">
            <summary>
            Gets the real time handler used to process real time events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.MapFileProvider">
            <summary>
            Gets the map file provider used as a map file source for the data feed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FactorFileProvider">
            <summary>
            Gets the map file provider used as a map file source for the data feed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataProvider">
            <summary>
            Gets the data file provider used to retrieve security data if it is not on the file system
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataCacheProvider">
            <summary>
            Gets the data file provider used to retrieve security data if it is not on the file system
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.ObjectStore">
            <summary>
            Gets the object store used for persistence
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataPermissionsManager">
            <summary>
            Entity in charge of handling data permissions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataMonitor">
            <summary>
            Monitors data requests and reports on missing data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Interfaces.IObjectStore,QuantConnect.Interfaces.IDataPermissionManager,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers"/> class from the specified handlers
            </summary>
            <param name="results">The result handler for communicating results from the algorithm</param>
            <param name="setup">The setup handler used to initialize algorithm state</param>
            <param name="dataFeed">The data feed handler used to pump data to the algorithm</param>
            <param name="transactions">The transaction handler used to process orders from the algorithm</param>
            <param name="realTime">The real time handler used to process real time events</param>
            <param name="mapFileProvider">The map file provider used to retrieve map files for the data feed</param>
            <param name="factorFileProvider">Map file provider used as a map file source for the data feed</param>
            <param name="dataProvider">file provider used to retrieve security data if it is not on the file system</param>
            <param name="objectStore">The object store used for persistence</param>
            <param name="dataPermissionsManager">The data permission manager to use</param>
            <param name="liveMode">True for live mode, false otherwise</param>
            <param name="researchMode">True for research mode, false otherwise. This has less priority than liveMode</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FromConfiguration(QuantConnect.Util.Composer,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers"/> class from the specified composer using type names from configuration
            </summary>
            <param name="composer">The composer instance to obtain implementations from</param>
            <param name="researchMode">True for research mode, false otherwise</param>
            <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> instance.</returns>
            <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers">
            <summary>
            Provides a container for the system level handlers
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Api">
            <summary>
            Gets the api instance used for communicating algorithm limits, status, and storing of log data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Notify">
            <summary>
            Gets the messaging handler instance used for communicating various packets to listeners, including
            debug/log messages, email/sms/web messages, as well as results and run time errors
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.JobQueue">
            <summary>
            Gets the job queue responsible for acquiring and acknowledging an algorithm job
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.LeanManager">
            <summary>
            Gets the ILeanManager implementation using to enhance the hosting environment
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.#ctor(QuantConnect.Interfaces.IJobQueueHandler,QuantConnect.Interfaces.IApi,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Lean.Engine.Server.ILeanManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> class with the specified handles
            </summary>
            <param name="jobQueue">The job queue used to acquire algorithm jobs</param>
            <param name="api">The api instance used for communicating limits and status</param>
            <param name="notify">The messaging handler user for passing messages from the algorithm to listeners</param>
            <param name="leanManager"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.FromConfiguration(QuantConnect.Util.Composer)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> class from the specified composer using type names from configuration
            </summary>
            <param name="composer">The composer instance to obtain implementations from</param>
            <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> instance.</returns>
            <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Initialize">
            <summary>
            Initializes the Api, Messaging, and JobQueue components
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler">
            <summary>
            Pseudo realtime event processing for backtesting to simulate realtime events in fast forward.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.IsActive">
            <summary>
            Flag indicating the hander thread is completely finished and ready to dispose.
            this doesn't run as its own thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Remove(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Removes the specified event from the schedule
            </summary>
            <param name="scheduledEvent">The event to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the time for the realtime event handler.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.SortFirstElement(System.Collections.Generic.IList{QuantConnect.Scheduling.ScheduledEvent})">
            <summary>
            Sorts the first element of the provided list and supposes the rest of the collection is sorted.
            Supposes the collection has at least 1 element
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler">
            <summary>
            Base class for the real time handler <see cref="T:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler"/>
            and <see cref="T:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler"/> implementations
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler._algorithmOnEndOfDay">
            <summary>
            Keep track of this event so we can remove it when we need to update it
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler._securityOnEndOfDay">
            <summary>
            Keep a separate track of these scheduled events so we can remove them
            if the security gets removed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.ResultHandler">
            <summary>
            The result handler instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.IsActive">
            <summary>
            Thread status flag.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.ScheduledEvents">
            <summary>
            The scheduled events container
            </summary>
            <remarks>Initialize this immediately since the Initialize method gets
            called after IAlgorithm.Initialize, so we want to be ready to accept
            events as soon as possible</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.IsolatorLimitProvider">
            <summary>
            The isolator limit result provider instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.TimeMonitor">
            <summary>
            The time monitor instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times
            the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Remove(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Removes the specified event from the schedule
            </summary>
            <param name="scheduledEvent">The event to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the current time for the event scanner (so we can use same code for backtesting and live events)
            </summary>
            <param name="time">Current real or backtest time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job.
            Adds EndOfDayEvents
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.GetScheduledEventUniqueId">
            <summary>
            Gets a new scheduled event unique id
            </summary>
            <remarks>This value is used to order scheduled events in a deterministic way</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.GetTimeMonitorTimeout">
            <summary>
            Get's the timeout the scheduled task time monitor should use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.AddAlgorithmEndOfDayEvent(System.DateTime,System.DateTime,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="currentUtcTime">Specifies the current time in UTC, before which,
            no events will be scheduled. Specify null to skip this filter.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.AddSecurityDependentEndOfDayEvents(System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security},System.DateTime,System.DateTime,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market
            close by the specified time for each provided securities.
            </summary>
            <param name="securities">The securities for which we want to add the OnEndOfDay event</param>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="currentUtcTime">Specifies the current time in UTC, before which,
            no events will be scheduled. Specify null to skip this filter.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Exit">
            <summary>
            Stop the real time thread
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler">
            <summary>
            Real time event handler, trigger functions at regular or pretimed intervals
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.IsActive">
            <summary>
            Thread status flag.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the current time for the event scanner (so we can use same code for backtesting and live events)
            </summary>
            <param name="time">Current real or backtest time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Exit">
            <summary>
            Trigger and exit signal to terminate real time event scanner.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler">
            <summary>
            Live trading realtime event processing.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.MarketHoursDatabase">
            <summary>
            Gets the current market hours database instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.SymbolPropertiesDatabase">
            <summary>
            Gets the current symbol properties database instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.TimeProvider">
            <summary>
            Gets the time provider
            </summary>
            <remarks>
            This should be fixed to RealTimeHandler, but made a protected property for testing purposes
            </remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.IsActive">
            <summary>
            Boolean flag indicating thread state.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.GetTimeMonitorTimeout">
            <summary>
            Get's the timeout the scheduled task time monitor should use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Run">
            <summary>
            Execute the live realtime event thread montioring.
            It scans every second monitoring for an event trigger.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.RefreshMarketHours(System.DateTime)">
            <summary>
            Refresh the market hours for each security in the given date
            </summary>
            <remarks>Each time this method is called, the MarketHoursDatabase is reset</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.RefreshSymbolProperties">
            <summary>
            Refresh the symbol properties for each security
            </summary>
            <remarks>
            - Each time this method is called, the SymbolPropertiesDatabase is reset
            - Made protected virtual for testing purposes
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the current time. If the date changes re-start the realtime event setup routines.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Exit">
            <summary>
            Stop the real time thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.UpdateMarketHours(QuantConnect.Securities.Security)">
            <summary>
            Updates the market hours for the specified security.
            </summary>
            <remarks>
            - This is done after a MHDB refresh
            - Made protected virtual for testing purposes
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.UpdateSymbolProperties(QuantConnect.Securities.Security)">
            <summary>
            Updates the symbol properties for the specified security.
            </summary>
            <remarks>
            - This is done after a SPDB refresh
            - Made protected virtual for testing purposes
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.ResetMarketHoursDatabase">
            <summary>
            Resets the market hours database, forcing a reload when reused.
            Called in tests where multiple algorithms are run sequentially,
            and we need to guarantee that every test starts with the same environment.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.ResetSymbolPropertiesDatabase">
            <summary>
            Resets the symbol properties database, forcing a reload when reused.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory">
            <summary>
            Provides methods for creating common scheduled events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryDayAt(System.String,System.Collections.Generic.IEnumerable{System.DateTime},System.TimeSpan,System.Action{System.String,System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire at the specified <paramref name="timeOfDay"/> for every day in
            <paramref name="dates"/>
            </summary>
            <param name="name">An identifier for this event</param>
            <param name="dates">The dates to set events for at the specified time. These act as a base time to which
            the <paramref name="timeOfDay"/> is added to, that is, the implementation does not use .Date before
            the addition</param>
            <param name="timeOfDay">The time each tradeable date to fire the event</param>
            <param name="callback">The delegate to call when an event fires</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>A new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> instance that fires events each tradeable day from the start to the finish at the specified time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryAlgorithmEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="algorithm">The algorithm instance the event is fo</param>
            <param name="resultHandler">The result handler, used to communicate run time errors</param>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire near market close each tradeable dat</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EverySecurityEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Securities.Security,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="algorithm">The algorithm instance the event is fo</param>
            <param name="resultHandler">The result handler, used to communicate run time errors</param>
            <param name="security">The security used for defining tradeable dates</param>
            <param name="start">The first date for the events</param>
            <param name="end">The date to end the events</param>
            <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire near market close each tradeable dat</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.CreateEventName(System.String,System.String)">
            <summary>
            Defines the format of event names generated by this system.
            </summary>
            <param name="scope">The scope of the event, example, 'Algorithm' or 'Security'</param>
            <param name="name">A name for this specified event in this scope, example, 'EndOfDay'</param>
            <returns>A string representing a fully scoped event name</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BacktestingResultHandler">
            <summary>
            Backtesting result handler passes messages back from the Lean to the User.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BacktestingResultHandler._capacityEstimate">
            <summary>
            Calculates the capacity of a strategy per Symbol in real-time
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.FinalStatistics">
            <summary>
            A dictionary containing summary statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Initialize(QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Run">
            <summary>
            The main processing method steps through the messaging queue and processes the messages one by one.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Update">
            <summary>
            Send a backtest update to the browser taking a latest snapshot of the charting data.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.SortedDictionary{System.String,System.String},System.Decimal,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendFinalResult">
            <summary>
            Send a final analysis result back to the IDE.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the Algorithm instance for ths result.
            </summary>
            <param name="algorithm">Algorithm we're working on.</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
            <remarks>While setting the algorithm the backtest result handler.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.AlgorithmNameUpdated(System.String)">
            <summary>
            Handles updates to the algorithm's name
            </summary>
            <param name="name">The new name</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.AlgorithmTagsUpdated(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Sends a packet communicating an update to the algorithm's tags
            </summary>
            <param name="tags">The new tags</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.DebugMessage(System.String)">
            <summary>
            Send a debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a system debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.AddToLogStore(System.String)">
            <summary>
            Add message to LogStore
            </summary>
            <param name="message">Message to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send list of security asset types the algorithm uses to browser.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="message">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.BrokerageMessage(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Process brokerage message events
            </summary>
            <param name="brokerageMessageEvent">The brokerage message event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,QuantConnect.ISeriesPoint,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesIndex">Type of chart we should create if it doesn't already exist.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="value">Value for the chart sample.</param>
            <param name="unit">Unit of the sample</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleCapacity(System.DateTime)">
            <summary>
            Sample estimated strategy capacity
            </summary>
            <param name="time">Time of the sample</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleRange(System.Collections.Generic.IEnumerable{QuantConnect.Chart})">
            <summary>
            Add a range of samples from the users algorithms to the end of our current list.
            </summary>
            <param name="updates">Chart updates since the last request.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send an algorithm status update to the browser.
            </summary>
            <param name="status">Status enum value.</param>
            <param name="message">Additional optional status message.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set the current runtime statistics of the algorithm.
            These are banner/title statistics which show at the top of the live trading results.
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Handle order event
            </summary>
            <param name="newEvent">Event to process</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process the synchronous result events, sampling and message reading.
            This method is triggered from the algorithm manager thread.
            </summary>
            <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ConfigureConsoleTextWriter(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Configures the <see cref="P:System.Console.Out"/> and <see cref="P:System.Console.Error"/> <see cref="T:System.IO.TextWriter"/>
            instances. By default, we forward <see cref="M:System.Console.WriteLine(System.String)"/> to <see cref="M:QuantConnect.Interfaces.IAlgorithm.Debug(System.String)"/>.
            This is perfect for running in the cloud, but since they're processed asynchronously, the ordering of these
            messages with respect to <see cref="T:QuantConnect.Logging.Log"/> messages is broken. This can lead to differences in regression
            test logs based solely on the ordering of messages. To disable this forwarding, set <code>"forward-console-messages"</code>
            to <code>false</code> in the configuration.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.StatisticsResults">
            <summary>
            Calculates and gets the current statistics for the algorithm
            </summary>
            <returns>The current statistics</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SetSummaryStatistic(System.String,System.String)">
            <summary>
            Sets or updates a custom summary statistic
            </summary>
            <param name="name">The statistic name</param>
            <param name="value">The statistic value</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor">
            <summary>
            Monitors and reports the progress of a backtest
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor.TotalDays">
            <summary>
            Gets the total days the algorithm will run
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor.ProcessedDays">
            <summary>
            Gets the current days the algorithm has been running for
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor.Progress">
            <summary>
            Gets the current progress of the backtest
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor.#ctor(QuantConnect.Interfaces.ITimeKeeper,System.DateTime)">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeKeeper">The time keeper to use</param>
            <param name="endUtcTime">The end UTC time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestProgressMonitor.InvalidateProcessedDays">
            <summary>
            Invalidates the processed days count value so it gets recalculated next time it is needed
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BaseResultsHandler">
            <summary>
            Provides base functionality to the implementations of <see cref="T:QuantConnect.Lean.Engine.Results.IResultHandler"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StrategyEquityKey">
            <summary>
            String message saying: Strategy Equity
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.EquityKey">
            <summary>
            String message saying: Equity
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ReturnKey">
            <summary>
            String message saying: Return
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.BenchmarkKey">
            <summary>
            String message saying: Benchmark
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.DrawdownKey">
            <summary>
            String message saying: Drawdown
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.PortfolioTurnoverKey">
            <summary>
            String message saying: PortfolioTurnover
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.PortfolioMarginKey">
            <summary>
            String message saying: Portfolio Margin
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.MainUpdateInterval">
            <summary>
            The main loop update interval
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ChartUpdateInterval">
            <summary>
            The chart update interval
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LastDeltaOrderPosition">
            <summary>
            The last position consumed from the <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> by <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetDeltaOrders(System.Int32,System.Func{System.Int32,System.Boolean})"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LastDeltaOrderEventsPosition">
            <summary>
            The last position consumed from the <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> while determining delta order events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SerializerSettings">
            <summary>
            Serializer settings to use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CurrentAlgorithmEquity">
            <summary>
            The current aggregated equity bar for sampling.
            It will be aggregated with values from the <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetPortfolioValue"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler._updateRunner">
            <summary>
            The task in charge of running the <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Run"/> update method
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.IsActive">
            <summary>
            Boolean flag indicating the thread is still active.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Messages">
            <summary>
            Live packet messaging queue. Queue the messages here and send when the result queue is ready.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Charts">
            <summary>
            Storage for the price and equity charts of the live results.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ExitTriggered">
            <summary>
            True if the exit has been triggered
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ExitEvent">
            <summary>
            Event set when exit is triggered
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LogStore">
            <summary>
            The log store instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlgorithmPerformanceCharts">
            <summary>
            Algorithms performance related chart names
            </summary>
            <remarks>Used to calculate the probabilistic sharpe ratio</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ChartLock">
            <summary>
            Lock to be used when accessing the chart collection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ProjectId">
            <summary>
            The algorithm project id
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.RamAllocation">
            <summary>
            The maximum amount of RAM (in MB) this algorithm is allowed to utilize
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CompileId">
            <summary>
            The algorithm unique compilation id
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlgorithmId">
            <summary>
            The algorithm job id.
            This is the deploy id for live, backtesting id for backtesting
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StartTime">
            <summary>
            The result handler start time
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.RuntimeStatistics">
            <summary>
            Customizable dynamic statistics <see cref="P:QuantConnect.Interfaces.IAlgorithm.RuntimeStatistics"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.State">
            <summary>
            State of the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.MessagingHandler">
            <summary>
            The handler responsible for communicating messages to listeners
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.TransactionHandler">
            <summary>
            The transaction handler used to get the algorithms Orders information
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StartingPortfolioValue">
            <summary>
            The algorithms starting portfolio value.
            Used to calculate the portfolio return
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlgorithmCurrencySymbol">
            <summary>
            Algorithm currency symbol, used in charting
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.DailyPortfolioValue">
            <summary>
            Closing portfolio value. Used to calculate daily performance.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CumulativeMaxPortfolioValue">
            <summary>
            Cumulative max portfolio value. Used to calculate drawdown underwater.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ResamplePeriod">
            <summary>
            Sampling period for timespans between resamples of the charting equity.
            </summary>
            <remarks>Specifically critical for backtesting since with such long timeframes the sampled data can get extreme.</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.NotificationPeriod">
            <summary>
            How frequently the backtests push messages to the browser.
            </summary>
            <remarks>Update frequency of notification packets</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ResultsDestinationFolder">
            <summary>
            Directory location to store results
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.MapFileProvider">
            <summary>
            The map file provider instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            New order event for the algorithm
            </summary>
            <param name="newEvent">New event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetServerStatistics(System.DateTime)">
            <summary>
            Gets the current Server statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StoreOrderEvents(System.DateTime,System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Stores the order events
            </summary>
            <param name="utcTime">The utc date associated with these order events</param>
            <param name="orderEvents">The order events to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StoreInsights">
            <summary>
            Save insight results to persistent storage
            </summary>
            <remarks>Method called by the storing timer and on exit</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetDeltaOrders(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Gets the orders generated starting from the provided <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> position
            </summary>
            <returns>The delta orders</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Initialize(QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="parameters">DTO parameters class to initialize a result handler</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Run">
            <summary>
            Result handler update method
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetResultsPath(System.String)">
            <summary>
            Gets the full path for a results file
            </summary>
            <param name="filename">The filename to add to the path</param>
            <returns>The full path, including the filename</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SaveLogs(System.String,System.Collections.Generic.List{QuantConnect.Logging.LogEntry})">
            <summary>
            Returns the location of the logs
            </summary>
            <param name="id">Id that will be incorporated into the algorithm log name</param>
            <param name="logs">The logs to save</param>
            <returns>The path to the logs</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results to disk
            </summary>
            <param name="name">The name of the results</param>
            <param name="result">The results to save</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.PurgeQueue">
            <summary>
            Purge/clear any outstanding messages in message queue.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StopUpdateRunner">
            <summary>
            Stops the update runner task
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetNetReturn">
            <summary>
            Gets the algorithm net return
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetPortfolioValue">
            <summary>
            Gets the current portfolio value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetBenchmarkValue(System.DateTime)">
            <summary>
            Gets the current benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
            <param name="time">Time to resolve benchmark value at</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Sample(System.DateTime)">
            <summary>
            Samples portfolio equity, benchmark, and daily performance
            Called by scheduled event every night at midnight algorithm time
            </summary>
            <param name="time">Current UTC time in the AlgorithmManager loop</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleEquity(System.DateTime)">
            <summary>
            Sample the current equity of the strategy directly with time and using
            the current algorithm equity value in <see cref="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CurrentAlgorithmEquity"/>
            </summary>
            <param name="time">Equity candlestick end time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SamplePerformance(System.DateTime,System.Decimal)">
            <summary>
            Sample the current daily performance directly with a time-value pair.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Current daily performance value.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleBenchmark(System.DateTime,System.Decimal)">
            <summary>
            Sample the current benchmark performance directly with a time-value pair.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Current benchmark value.</param>
            <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.DateTime)"/>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleDrawdown(System.DateTime,System.Decimal)">
            <summary>
            Sample drawdown of equity of the strategy
            </summary>
            <param name="time">Time of the sample</param>
            <param name="currentPortfolioValue">Current equity value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SamplePortfolioTurnover(System.DateTime,System.Decimal)">
            <summary>
            Sample portfolio turn over of the strategy
            </summary>
            <param name="time">Time of the sample</param>
            <param name="currentPortfolioValue">Current equity value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleSalesVolume(System.DateTime)">
            <summary>
            Sample assets sales volume
            </summary>
            <param name="time">Time of the sample</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleExposure(System.DateTime,System.Decimal)">
            <summary>
            Sample portfolio exposure long/short ratios by security type
            </summary>
            <param name="time">Time of the sample</param>
            <param name="currentPortfolioValue">Current value of the portfolio</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleExposureHelper(QuantConnect.PositionSide,System.DateTime,System.Decimal,System.Collections.Generic.Dictionary{QuantConnect.SecurityType,System.Decimal})">
            <summary>
            Helper method for SampleExposure, samples our holdings value to
            our exposure chart by their position side and security type
            </summary>
            <param name="type">Side to sample from portfolio</param>
            <param name="time">Time of the sample</param>
            <param name="currentPortfolioValue">Current value of the portfolio</param>
            <param name="holdings">Enumerable of holdings to sample</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleCapacity(System.DateTime)">
            <summary>
            Sample estimated strategy capacity
            </summary>
            <param name="time">Time of the sample</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,QuantConnect.ISeriesPoint,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesIndex">Series chart index - which chart should this series belong</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="value">Value for the chart sample.</param>
            <param name="unit">Unit for the chart axis</param>
            <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetAlgorithmRuntimeStatistics(System.Collections.Generic.Dictionary{System.String,System.String},QuantConnect.CapacityEstimate)">
            <summary>
            Gets the algorithm runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SetAlgorithmState(System.String,System.String)">
            <summary>
            Sets the algorithm state data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetAlgorithmState(System.Nullable{System.DateTime})">
            <summary>
            Gets the algorithm state data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GenerateStatisticsResults(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},QuantConnect.CapacityEstimate)">
            <summary>
            Will generate the statistics results and update the provided runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.TotalTradesCount">
            <summary>
            Helper method to get the total trade count statistic
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GenerateStatisticsResults(QuantConnect.CapacityEstimate)">
            <summary>
            Calculates and gets the current statistics for the algorithm.
            It will use the current <see cref="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Charts"/> and profit loss information calculated from the current transaction record
            to generate the results.
            </summary>
            <returns>The current statistics</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ProcessAlgorithmLogs(System.Nullable{System.Int32})">
            <summary>
            Processes algorithm logs.
            Logs of the same type are batched together one per line and are sent out
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SummaryStatistic(System.String,System.String)">
            <summary>
            Sets or updates a custom summary statistic
            </summary>
            <param name="name">The statistic name</param>
            <param name="value">The statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.UpdateAlgorithmEquity(QuantConnect.Data.Market.Bar)">
            <summary>
            Updates the current equity bar with the current equity value from <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetPortfolioValue"/>
            </summary>
            <remarks>
            This is required in order to update the <see cref="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CurrentAlgorithmEquity"/> bar without using the getter,
            which would cause the bar to be created if it doesn't exist.
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.UpdateAlgorithmEquity">
            <summary>
            Updates the current equity bar with the current equity value from <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetPortfolioValue"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.IResultHandler">
            <summary>
            Handle the results of the backtest: where should we send the profit, portfolio updates:
            Backtester or the Live trading platform:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.Messages">
            <summary>
            Put messages to process into the queue so they are processed by this thread.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.IsActive">
            <summary>
            Boolean flag indicating the result hander thread is busy.
            False means it has completely finished and ready to dispose.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Initialize(QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="parameters">DTO parameters class to initialize a result handler</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.DebugMessage(System.String)">
            <summary>
            Process debug messages with the preconfigured settings.
            </summary>
            <param name="message">String debug message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Process system debug messages with the preconfigured settings.
            </summary>
            <param name="message">String debug message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send a list of security types to the browser
            </summary>
            <param name="types">Security types list inside algorithm</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="error">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.BrokerageMessage(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Process brokerage message events
            </summary>
            <param name="brokerageMessageEvent">The brokerage message event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.DateTime)">
            <summary>
            Method to update the <see cref="T:QuantConnect.Lean.Engine.Results.IResultHandler"/> with various performance metrics.
            Called once a day by scheduled event in AlgorithmManager
            </summary>
            <param name="time">Current time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the algorithm of the result handler after its been initialized.
            </summary>
            <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send a algorithm status update to the user of the algorithms running state.
            </summary>
            <param name="status">Status enum of the algorithm.</param>
            <param name="message">Optional string message describing reason for status change.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set a dynamic runtime statistic to show in the (live) algorithm header
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Send a new order event.
            </summary>
            <param name="newEvent">Update, processing or cancellation of an order, update the IDE in live mode or ignore in backtesting.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process any synchronous events in here that are primarily triggered from the algorithm loop
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results
            </summary>
            <param name="name">The name of the results</param>
            <param name="result">The results to save</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.AlgorithmNameUpdated(System.String)">
            <summary>
            Handles updates to the algorithm's name
            </summary>
            <param name="name">The new name</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.AlgorithmTagsUpdated(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Handles updates to the algorithm's tags
            </summary>
            <param name="tags">The new tags</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler">
            <summary>
            Live trading result handler implementation passes the messages to the QC live trading interface.
            </summary>
            <remarks>Live trading result handler is quite busy. It sends constant price updates, equity updates and order/holdings updates.</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler._nextStatusUpdate">
            <summary>
            The earliest time of next dump to the status file
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Initialize(QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="parameters">DTO parameters class to initialize a result handler</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Run">
            <summary>
            Live trading result handler thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Update">
            <summary>
            Every so often send an update to the browser with the current state of the algorithm.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetNextStatusUpdate">
            <summary>
            Assigns the next earliest status update time
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreOrderEvents(System.DateTime,System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Stores the order events
            </summary>
            <param name="utcTime">The utc date associated with these order events</param>
            <param name="orderEvents">The order events to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetOrderEventsToStore">
            <summary>
            Gets the order events generated in '_currentUtcDate'
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreStatusFile(System.Collections.Generic.SortedDictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,System.String},QuantConnect.Statistics.StatisticsResults)">
            <summary>
            Will store the complete status of the algorithm in a single json file
            </summary>
            <remarks>Will sample charts every 12 hours, 2 data points per day at maximum,
            to reduce file size</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Securities.CashBook,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.SortedDictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.DebugMessage(System.String)">
            <summary>
            Send a live trading debug message to the live console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
            <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a live trading system debug message to the live console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.LogMessage(System.String)">
            <summary>
            Log string messages and send them to the console.
            </summary>
            <param name="message">String message wed like logged.</param>
            <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to send to browser.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser console and highlight it read.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace to show in the console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send a list of secutity types that the algorithm trades to the browser to show the market clock - is this market open or closed!
            </summary>
            <param name="types">List of security types</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error back to the users browser and highlight it red.
            </summary>
            <param name="message">Runtime error message</param>
            <param name="stacktrace">Associated error stack trace.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.BrokerageMessage(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Process brokerage message events
            </summary>
            <param name="brokerageMessageEvent">The brokerage message event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,QuantConnect.ISeriesPoint,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesIndex">Series chart index - which chart should this series belong</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="value">Value for the chart sample.</param>
            <param name="unit">Unit for the chart axis</param>
            <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleRange(System.Collections.Generic.IEnumerable{QuantConnect.Chart})">
            <summary>
            Add a range of samples from the users algorithms to the end of our current list.
            </summary>
            <param name="updates">Chart updates since the last request.</param>
            <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,QuantConnect.ISeriesPoint,System.String)"/>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the algorithm of the result handler after its been initialized.
            </summary>
            <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send a algorithm status update to the user of the algorithms running state.
            </summary>
            <param name="status">Status enum of the algorithm.</param>
            <param name="message">Optional string message describing reason for status change.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set a dynamic runtime statistic to show in the (live) algorithm header
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendFinalResult">
            <summary>
            Send a final analysis result back to the IDE.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SaveLogs(System.String,System.Collections.Generic.List{QuantConnect.Logging.LogEntry})">
            <summary>
            Process the log entries and save it to permanent storage
            </summary>
            <param name="id">Id that will be incorporated into the algorithm log name</param>
            <param name="logs">Log list</param>
            <returns>Returns the location of the logs</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            New order event for the algorithm
            </summary>
            <param name="newEvent">New event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Truncate(QuantConnect.Packets.LiveResult,System.DateTime,System.DateTime)">
            <summary>
            Truncates the chart and order data in the result packet to within the specified time frame
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.CreateSafeChartName(System.String)">
            <summary>
            Escape the chartname so that it can be saved to a file system
            </summary>
            <param name="chartName">The name of a chart</param>
            <returns>The name of the chart will all escape all characters except RFC 2396 unreserved characters</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process the synchronous result events, sampling and message reading.
            This method is triggered from the algorithm manager thread.
            </summary>
            <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed.
            On Security change we re determine when should we sample charts, if the user added Crypto, Forex or an extended market hours subscription
            we will always sample charts. Else, we will keep the exchange per market to query later on demand
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.DateTime)">
            <summary>
            Samples portfolio equity, benchmark, and daily performance
            </summary>
            <param name="time">Current UTC time in the AlgorithmManager loop</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetPortfolioValue">
            <summary>
            Gets the current portfolio value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetBenchmarkValue(System.DateTime)">
            <summary>
            Gets the current benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
            <param name="time">Time to resolve benchmark value at</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.UserExchangeIsOpen(System.DateTime)">
            <summary>
            True if user exchange are open and we should update portfolio and benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.UpdateAlgorithmStatus">
            <summary>
            Will launch a task which will call the API and update the algorithm status every minute
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetHoldings(System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security},QuantConnect.Interfaces.ISubscriptionDataConfigService,System.Boolean)">
            <summary>
            Helper method to fetch the algorithm holdings
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StatisticsResults">
            <summary>
            Calculates and gets the current statistics for the algorithm
            </summary>
            <returns>The current statistics</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetSummaryStatistic(System.String,System.String)">
            <summary>
            Sets or updates a custom summary statistic
            </summary>
            <param name="name">The statistic name</param>
            <param name="value">The statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.AlgorithmNameUpdated(System.String)">
            <summary>
            Handles updates to the algorithm's name
            </summary>
            <param name="name">The new name</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.AlgorithmTagsUpdated(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Handles updates to the algorithm's tags
            </summary>
            <param name="tags">The new tags</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.RegressionResultHandler">
            <summary>
            Provides a wrapper over the <see cref="T:QuantConnect.Lean.Engine.Results.BacktestingResultHandler"/> that logs all order events
            to a separate file
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.RegressionResultHandler.LogFilePath">
            <summary>
            Gets the path used for logging all portfolio changing events, such as orders, TPV, daily holdings values
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.RegressionResultHandler.HasRuntimeError">
            <summary>
            True if there was a runtime error running the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Results.RegressionResultHandler"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Initializes the stream writer using the algorithm's id (name) in the file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
            <summary>
            Runs on date changes, use this to log TPV and holdings values each day
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Log the order and order event to the dedicated log file for this regression algorithm
            </summary>
            <remarks>In backtesting the order events are not sent because it would generate a high load of messaging.</remarks>
            <param name="newEvent">New order event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send list of security asset types the algortihm uses to browser.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.DebugMessage(System.String)">
            <summary>
            Send a debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="message">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a system debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set the current runtime statistics of the algorithm.
            These are banner/title statistics which show at the top of the live trading results.
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Runs at the end of each time loop. When HighFidelityLogging is enabled, we'll
            log each piece of data to allow for faster determination of regression causes
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results to disk
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures.
            Save orders log files to disk.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ConfigureConsoleTextWriter(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            We want to make algorithm messages end up in both the standard regression log file {algorithm}.{language}.log
            as well as the details log {algorithm}.{language}.details.log. The details log is focused on providing a log
            dedicated solely to the algorithm's behavior, void of all <see cref="T:QuantConnect.Logging.Log"/> messages
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters">
            <summary>
            DTO parameters class to initialize a result handler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.Job">
            <summary>
            The algorithm job
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.MessagingHandler">
            <summary>
            The messaging handler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.Api">
            <summary>
            The Api instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.TransactionHandler">
            <summary>
            The transaction handler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.MapFileProvider">
            <summary>
            The map file provider instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.ResultHandlerInitializeParameters.#ctor(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Interfaces.IMapFileProvider)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Server.ILeanManager">
            <summary>
            Provides scope into Lean that is convenient for managing a lean instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.Initialize(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager)">
            <summary>
            Initialize the ILeanManager implementation
            </summary>
            <param name="systemHandlers">Exposes lean engine system handlers running LEAN</param>
            <param name="algorithmHandlers">Exposes the lean algorithm handlers running lean</param>
            <param name="job">The job packet representing either a live or backtest Lean instance</param>
            <param name="algorithmManager">The Algorithm manager</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Sets the IAlgorithm instance in the ILeanManager
            </summary>
            <param name="algorithm">The IAlgorithm instance being run</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.Update">
            <summary>
            Update ILeanManager with the IAlgorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.OnAlgorithmStart">
            <summary>
            This method is called after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.OnAlgorithmEnd">
            <summary>
            This method is called before algorithm termination
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Callback fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Server.LocalLeanManager">
            <summary>
            NOP implementation of the ILeanManager interface
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Server.LocalLeanManager.Algorithm">
            <summary>
            The current algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Server.LocalLeanManager.SystemHandlers">
            <summary>
            The system handlers
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Server.LocalLeanManager.AlgorithmHandlers">
            <summary>
            The algorithm handlers
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Initialize(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager)">
            <summary>
            Empty implementation of the ILeanManager interface
            </summary>
            <param name="systemHandlers">Exposes lean engine system handlers running LEAN</param>
            <param name="algorithmHandlers">Exposes the lean algorithm handlers running lean</param>
            <param name="job">The job packet representing either a live or backtest Lean instance</param>
            <param name="algorithmManager">The Algorithm manager</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Sets the IAlgorithm instance in the ILeanManager
            </summary>
            <param name="algorithm">The IAlgorithm instance being run</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Update">
            <summary>
            Execute the commands using the IAlgorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.OnAlgorithmStart">
            <summary>
            This method is called after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.OnAlgorithmEnd">
            <summary>
            This method is called before algorithm termination
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Callback fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException">
            <summary>
            Defines an exception generated in the course of invoking <see cref="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException"/> class
            </summary>
            <param name="message">The error message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException"/> class
            </summary>
            <param name="message">The error message</param>
            <param name="inner">The inner exception being wrapped</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler">
            <summary>
            Backtesting setup handler processes the algorithm initialize method and sets up the internal state of the algorithm class.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Errors">
            <summary>
            Internal errors list from running the setup procedures.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaximumRuntime">
            <summary>
            Maximum runtime of the algorithm in seconds.
            </summary>
            <remarks>Maximum runtime is a formula based on the number and resolution of symbols requested, and the days backtesting</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingPortfolioValue">
            <summary>
            Starting capital according to the users initialize routine.
            </summary>
            <remarks>Set from the user code.</remarks>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetCash(System.Decimal)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetStartDate(System.DateTime)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for this backtest.
            </summary>
            <remarks>To stop algorithm flooding the backtesting system with hundreds of megabytes of order data we limit it to 100 per day</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.#ctor">
            <summary>
            Initialize the backtest setup handler.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.Backtesting.BacktestingBrokerage"/> instance
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Setup the algorithm cash, dates and data subscriptions as desired.
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>Boolean true on successfully initializing the algorithm</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BaseSetupHandler">
            <summary>
             Base class that provides shared code for
            the <see cref="T:QuantConnect.Lean.Engine.Setup.ISetupHandler"/> implementations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.AlgorithmCreationTimeout">
            <summary>
            Get the maximum time that the creation of an algorithm can take
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.SetupCurrencyConversions(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.UniverseSelection,System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Will first check and add all the required conversion rate securities
            and later will seed an initial value to them.
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="universeSelection">The universe selection instance</param>
            <param name="currenciesToUpdateWhiteList">
            If passed, the currencies in the CashBook that are contained in this list will be updated.
            By default, if not passed (null), all currencies in the cashbook without a properly set up currency conversion will be updated.
            This is not intended for actual algorithms but for tests or for this method to be used as a helper.
            </param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.InitializeDebugging(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Util.WorkerThread)">
            <summary>
            Initialize the debugger
            </summary>
            <param name="algorithmNodePacket">The algorithm node packet</param>
            <param name="workerThread">The worker thread instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobCashAmount(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)">
            <summary>
            Sets the initial cash for the algorithm if set in the job packet.
            </summary>
            <remarks>Should be called after initialize <see cref="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobAccountCurrency(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobAccountCurrency(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)">
            <summary>
            Sets the account currency the algorithm should use if set in the job packet
            </summary>
            <remarks>Should be called before initialize <see cref="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobCashAmount(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.GetConfiguredDataFeeds">
            <summary>
            Get the available data feeds from config.json,
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.SetBrokerageTradingDayPerYear(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Set the number of trading days per year based on the specified brokerage model.
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <returns>
            The number of trading days per year. For specific brokerages (Coinbase, Binance, Bitfinex, Bybit, FTX, Kraken),
            the value is 365. For other brokerages, the default value is 252.
            </returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler">
            <summary>
            Defines a set up handler that initializes the algorithm instance using values retrieved from the user's brokerage account
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaxAllocationLimitConfig">
            <summary>
            Max allocation limit configuration variable name
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Errors">
            <summary>
            Any errors from the initialization stored here:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaximumRuntime">
            <summary>
            Get the maximum runtime for this algorithm job.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingPortfolioValue">
            <summary>
            Algorithm starting capital for statistics calculations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for the algorithm run -- applicable for backtests only.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.#ctor">
            <summary>
            Initializes a new BrokerageSetupHandler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates the brokerage as specified by the job packet
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Primary entry point to setup a new algorithm
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>True on successfully setting up the algorithm state, or false on error.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.LoadExistingHoldingsAndOrders(QuantConnect.Interfaces.IBrokerage,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Loads existing holdings and orders
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.GetOpenOrders(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Interfaces.IBrokerage)">
            <summary>
            Get the open orders from a brokerage. Adds <see cref="T:QuantConnect.Orders.Order"/> and <see cref="T:QuantConnect.Orders.OrderTicket"/> to the transaction handler
            </summary>
            <param name="algorithm">Algorithm instance</param>
            <param name="resultHandler">The configured result handler</param>
            <param name="transactionHandler">The configurated transaction handler</param>
            <param name="brokerage">Brokerage output instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.AddInitializationError(System.String,System.Exception)">
            <summary>
            Adds initialization error to the Errors list
            </summary>
            <param name="message">The error message to be added</param>
            <param name="inner">The inner exception being wrapped</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler">
            <summary>
            Kept for backwards compatibility-
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ISetupHandler">
            <summary>
            Interface to setup the algorithm. Pass in a raw algorithm, return one with portfolio, cash, etc already preset.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.Errors">
            <summary>
            Any errors from the initialization stored here:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaximumRuntime">
            <summary>
            Get the maximum runtime for this algorithm job.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingPortfolioValue">
            <summary>
            Algorithm starting capital for statistics calculations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for the algorithm run -- applicable for backtests only.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates the brokerage as specified by the job packet
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Primary entry point to setup a new algorithm
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>True on successfully setting up the algorithm state, or false on error.</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters">
            <summary>
            Defines the parameters for <see cref="T:QuantConnect.Lean.Engine.Setup.ISetupHandler"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.UniverseSelection">
            <summary>
            Gets the universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.Algorithm">
            <summary>
            Gets the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.Brokerage">
            <summary>
            Gets the Brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.AlgorithmNodePacket">
            <summary>
            Gets the algorithm node packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.ResultHandler">
            <summary>
            Gets the algorithm node packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.TransactionHandler">
            <summary>
            Gets the TransactionHandler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.RealTimeHandler">
            <summary>
            Gets the RealTimeHandler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.DataCacheProvider">
            <summary>
            Gets the DataCacheProvider
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.MapFileProvider">
            <summary>
            The map file provider instance of the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.#ctor(QuantConnect.Lean.Engine.DataFeeds.UniverseSelection,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Interfaces.IMapFileProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="universeSelection">The universe selection instance</param>
            <param name="algorithm">Algorithm instance</param>
            <param name="brokerage">New brokerage output instance</param>
            <param name="algorithmNodePacket">Algorithm job task</param>
            <param name="resultHandler">The configured result handler</param>
            <param name="transactionHandler">The configured transaction handler</param>
            <param name="realTimeHandler">The configured real time handler</param>
            <param name="dataCacheProvider">The configured data cache provider</param>
            <param name="mapFileProvider">The map file provider</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.FileHandler">
            <summary>
            Raw file handler
            </summary>
            <remarks>Useful to abstract file operations for <see cref="T:QuantConnect.Lean.Engine.Storage.LocalObjectStore"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.Exists(System.String)">
            <summary>
            True if the given file path exists
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.Delete(System.String)">
            <summary>
            Will delete the given file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.WriteAllBytes(System.String,System.Byte[])">
            <summary>
            Will write the given byte array at the target file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.ReadAllBytes(System.String)">
            <summary>
            Read all bytes in the given file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.TryGetFileLength(System.String)">
            <summary>
            Will try to fetch the given file length, will return 0 if it doesn't exist
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.DirectoryExists(System.String)">
            <summary>
            True if the given directory exists
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.CreateDirectory(System.String)">
            <summary>
            Create the requested directory path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.FileHandler.EnumerateFiles(System.String,System.String,System.IO.SearchOption,System.String@)">
            <summary>
            Enumerate the files in the target path
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.LocalObjectStore">
            <summary>
            A local disk implementation of <see cref="T:QuantConnect.Interfaces.IObjectStore"/>.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore.NoReadPermissionsError">
            <summary>
            No read permissions error message
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore.NoWritePermissionsError">
            <summary>
            No write permissions error message
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ErrorRaised">
            <summary>
            Event raised each time there's an error
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.DefaultObjectStore">
            <summary>
            Gets the default object store location
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore._dirty">
            <summary>
            Flag indicating the state of this object storage has changed since the last <seealso cref="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Persist"/> invocation
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Controls">
            <summary>
            Provides access to the controls governing behavior of this instance, such as the persistence interval
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.AlgorithmStorageRoot">
            <summary>
            The root storage folder for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.FileHandler">
            <summary>
            The file handler instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Initialize(System.Int32,System.Int32,System.String,QuantConnect.Packets.Controls)">
            <summary>
            Initializes the object store
            </summary>
            <param name="userId">The user id</param>
            <param name="projectId">The project id</param>
            <param name="userToken">The user token</param>
            <param name="controls">The job controls instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.StorageRoot">
            <summary>
            Storage root path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.GetObjectStoreEntries(System.Boolean,System.Boolean)">
            <summary>
            Loads objects from the AlgorithmStorageRoot into the ObjectStore
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Keys">
            <summary>
            Returns the file paths present in the object store. This is specially useful not to load the object store into memory
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Clear">
            <summary>
            Will clear the object store state cache. This is useful when the object store is used concurrently by nodes which want to share information
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ContainsKey(System.String)">
            <summary>
            Determines whether the store contains data for the specified path
            </summary>
            <param name="path">The object path</param>
            <returns>True if the key was found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ReadBytes(System.String)">
            <summary>
            Returns the object data for the specified path
            </summary>
            <param name="path">The object path</param>
            <returns>A byte array containing the data</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.SaveBytes(System.String,System.Byte[])">
            <summary>
            Saves the object data for the specified path
            </summary>
            <param name="path">The object path</param>
            <param name="contents">The object data</param>
            <returns>True if the save operation was successful</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.InternalSaveBytes(System.String,System.Byte[])">
            <summary>
            Won't trigger persist nor will check storage write permissions, useful on initialization since it allows read only permissions to load the object store
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.IsWithinStorageLimit(System.String,System.Byte[],System.Boolean)">
            <summary>
            Validates storage limits are respected on a new save operation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Delete(System.String)">
            <summary>
            Deletes the object data for the specified path
            </summary>
            <param name="path">The object path</param>
            <returns>True if the delete operation was successful</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.GetFilePath(System.String)">
            <summary>
            Returns the file path for the specified path
            </summary>
            <remarks>If the key is not already inserted it will just return a path associated with it
            and add the key with null value</remarks>
            <param name="path">The object path</param>
            <returns>The path for the file</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.PathForKey(System.String)">
            <summary>
            Get's a file path for a given path.
            Internal use only because it does not guarantee the existence of the file.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Persist">
            <summary>
            Invoked periodically to persist the object store's contents
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.PersistData">
            <summary>
            Overridable persistence function
            </summary>
            <returns>True if persistence was successful, otherwise false</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.OnErrorRaised(System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ErrorRaised"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.BytesToMb(System.Int64)">
            <summary>
            Converts a number of bytes to megabytes as it's more human legible
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ObjectStoreEntry">
            <summary>
            Helper class to hold the state of an object store file
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.StorageLimitExceededException">
            <summary>
            Exception thrown when the object store storage limit has been exceeded
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.StorageLimitExceededException.#ctor(System.String)">
            <summary>
            Creates a new instance of the storage limit exceeded exception
            </summary>
            <param name="message">The associated message</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler">
            <summary>
            This transaction handler is used for processing transactions during backtests
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.CurrentTimeUtc">
            <summary>
            Gets current time UTC. This is here to facilitate testing
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Creates a new BacktestingTransactionHandler using the BacktestingBrokerage
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="brokerage">The BacktestingBrokerage</param>
            <param name="resultHandler"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessSynchronousEvents">
            <summary>
            Processes all synchronous events that must take place before the next time loop for the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessAsynchronousEvents">
            <summary>
            Processes asynchronous events on the transaction handler's thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.WaitForOrderSubmission(QuantConnect.Orders.OrderTicket)">
            <summary>
            For backtesting we will submit the order ourselves
            </summary>
            <param name="ticket">The <see cref="T:QuantConnect.Orders.OrderTicket"/> expecting to be submitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.InitializeTransactionThread">
            <summary>
            For backtesting order requests will be processed by the algorithm thread
            sequentially at <see cref="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.WaitForOrderSubmission(QuantConnect.Orders.OrderTicket)"/> and <see cref="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessSynchronousEvents"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler">
            <summary>
            Transaction handler for all brokerages
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._orderRequestQueue">
            <summary>
            OrderQueue holds the newly updated orders from the user algorithm waiting to be processed. Once
            orders are processed they are moved into the Orders queue awaiting the brokerage response.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._completeOrders">
            <summary>
            The _completeOrders dictionary holds all orders.
            Once the transaction thread has worked on them they get put here while witing for fill updates.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._openOrders">
            <summary>
            The orders dictionary holds orders which are open. Status: New, Submitted, PartiallyFilled, None, CancelPending
            Once the transaction thread has worked on them they get put here while witing for fill updates.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._openOrderTickets">
            <summary>
            The _openOrderTickets dictionary holds open order tickets that the algorithm can use to reference a specific order. This
            includes invoking update and cancel commands. In the future, we can add more features to the ticket, such as events
            and async events (such as run this code when this order fills)
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._completeOrderTickets">
            <summary>
            The _completeOrderTickets dictionary holds all order tickets that the algorithm can use to reference a specific order. This
            includes invoking update and cancel commands. In the future, we can add more features to the ticket, such as events
            and async events (such as run this code when this order fills)
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._priceAdjustmentModes">
            <summary>
            Cache collection of price adjustment modes for each symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._cancelPendingOrders">
            <summary>
            The _cancelPendingOrders instance will help to keep track of CancelPending orders and their Status
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.NewOrderEvent">
            <summary>
            Event fired when there is a new <see cref="T:QuantConnect.Orders.OrderEvent"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Orders">
            <summary>
            Gets the permanent storage for all orders
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrderEvents">
            <summary>
            Gets all order events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrderTickets">
            <summary>
            Gets the permanent storage for all order tickets
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrdersCount">
            <summary>
            Gets the current number of orders that have been processed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Creates a new BrokerageTransactionHandler to process orders using the specified brokerage implementation
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="brokerage">The brokerage implementation to process orders and fire fill events</param>
            <param name="resultHandler"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.InitializeTransactionThread">
            <summary>
            Create and start the transaction thread, who will be in charge of processing
            the order requests
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.IsActive">
            <summary>
            Boolean flag indicating the Run thread method is busy.
            False indicates it is completely finished processing and ready to be terminated.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Process(QuantConnect.Orders.OrderRequest)">
            <summary>
            Adds the specified order to be processed
            </summary>
            <param name="request">The order to be processed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.AddOrder(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Add an order to collection and return the unique order id or negative if an error.
            </summary>
            <param name="request">A request detailing the order to be submitted</param>
            <returns>New unique, increasing orderid</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.WaitForOrderSubmission(QuantConnect.Orders.OrderTicket)">
            <summary>
            Wait for the order to be handled by the <see cref="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._processingThread"/>
            </summary>
            <param name="ticket">The <see cref="T:QuantConnect.Orders.OrderTicket"/> expecting to be submitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.UpdateOrder(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Update an order yet to be filled such as stop or limit orders.
            </summary>
            <param name="request">Request detailing how the order should be updated</param>
            <remarks>Does not apply if the order is already fully filled</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CancelOrder(QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Remove this order from outstanding queue: user is requesting a cancel.
            </summary>
            <param name="request">Request containing the specific order id to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets</param>
            <returns>An enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOpenOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of opened <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets</param>
            <returns>An enumerable of opened <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTicket(System.Int32)">
            <summary>
            Gets the order ticket for the specified order id. Returns null if not found
            </summary>
            <param name="orderId">The order's id</param>
            <returns>The order ticket with the specified id, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderById(System.Int32)">
            <summary>
            Get the order by its id
            </summary>
            <param name="orderId">Order id to fetch</param>
            <returns>A clone of the order with the specified id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrdersByBrokerageId(System.String)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets all orders matching the specified filter. Specifying null will return an enumerable
            of all orders.
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All orders this order provider currently holds by the specified filter</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOpenOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets open orders matching the specified filter
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All open orders this order provider currently holds</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Run">
            <summary>
            Primary thread entry point to launch the transaction thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessAsynchronousEvents">
            <summary>
            Processes asynchronous events on the transaction handler's thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessSynchronousEvents">
            <summary>
            Processes all synchronous events that must take place before the next time loop for the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.AddOpenOrder(QuantConnect.Orders.Order,QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Register an already open Order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Exit">
            <summary>
            Signal a end of thread request to stop monitoring the transactions.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleOrderRequest(QuantConnect.Orders.OrderRequest)">
            <summary>
            Handles a generic order request
            </summary>
            <param name="request"><see cref="T:QuantConnect.Orders.OrderRequest"/> to be handled</param>
            <returns><see cref="T:QuantConnect.Orders.OrderResponse"/> for request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleSubmitOrderRequest(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Handles a request to submit a new order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Handles a request to update order properties
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleCancelOrderRequest(QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Handles a request to cancel an order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.SetPriceAdjustmentMode(QuantConnect.Orders.Order,QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Gets the price adjustment mode for the specified symbol from its subscription configurations
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.LogOrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Debug logging helper method, called after HandleOrderEvent has finished updating status, price and quantity
            </summary>
            <param name="e">The order event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleAccountChanged(QuantConnect.Securities.AccountEvent)">
            <summary>
            Brokerages can send account updates, this include cash balance updates. Since it is of
            utmost important to always have an accurate picture of reality, we'll trust this information
            as truth
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandlerBrokerageOrderIdChangedEvent(QuantConnect.Orders.BrokerageOrderIdChangedEvent)">
            <summary>
            Brokerage order id change is applied to the target order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandlePositionAssigned(QuantConnect.Orders.OrderEvent)">
            <summary>
            Option assignment/exercise event is received and propagated to the user algo
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleOptionNotification(QuantConnect.Brokerages.OptionNotificationEventArgs)">
            <summary>
            Option notification event is received and new order events are generated
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleNewBrokerageSideOrder(QuantConnect.Brokerages.NewBrokerageOrderNotificationEventArgs)">
            <summary>
            New brokerage-side order event handler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.TimeSinceLastFill">
            <summary>
            Gets the amount of time since the last call to algorithm.Portfolio.ProcessFill(fill)
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CurrentTimeUtc">
            <summary>
            Gets current time UTC. This is here to facilitate testing
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOffOrder(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
            <summary>
            Rounds off the order towards 0 to the nearest multiple of Lot Size
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOrderPrices(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
            <summary>
            Rounds the order prices to its security minimum price variation.
            <remarks>
            This procedure is needed to meet brokerage precision requirements.
            </remarks>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOrderPrices(QuantConnect.Orders.Order,QuantConnect.Securities.Security,System.Boolean,System.Collections.Generic.Dictionary{QuantConnect.Orders.Order,QuantConnect.Securities.Security})">
            <summary>
            Rounds the order prices to its security minimum price variation.
            <remarks>
            This procedure is needed to meet brokerage precision requirements.
            </remarks>
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders">
            <summary>
            Class used to keep track of CancelPending orders and their original or updated status
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.GetCancelPendingOrdersSize">
            <summary>
            Amount of CancelPending Orders
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.Set(System.Int32,QuantConnect.Orders.OrderStatus)">
            <summary>
            Adds an order which will be canceled and we want to keep track of it Status in case of fallback
            </summary>
            <param name="orderId">The order id</param>
            <param name="status">The order Status, before the cancel request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.UpdateOrRemove(System.Int32,QuantConnect.Orders.OrderStatus)">
            <summary>
            Updates an order that is pending to be canceled.
            </summary>
            <param name="newStatus">The new status of the order. If its OrderStatus.Canceled or OrderStatus.Filled it will be removed</param>
            <param name="orderId">The id of the order</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.RemoveAndFallback(QuantConnect.Orders.Order)">
            <summary>
            Removes an order which we failed to cancel and falls back the order Status to previous value
            </summary>
            <param name="order">The order that failed to be canceled</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler">
            <summary>
            Transaction handlers define how the transactions are processed and set the order fill information.
            The pass this information back to the algorithm portfolio and ensure the cash and portfolio are synchronized.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.IsActive">
            <summary>
            Boolean flag indicating the thread is busy.
            False indicates it is completely finished processing and ready to be terminated.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Orders">
            <summary>
            Gets the permanent storage for all orders
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents">
            <summary>
            Gets all order events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderTickets">
            <summary>
            Gets the permanent storage for all order tickets
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Initializes the transaction handler for the specified algorithm using the specified brokerage implementation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Exit">
            <summary>
            Signal a end of thread request to stop montioring the transactions.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.ProcessSynchronousEvents">
            <summary>
            Process any synchronous events from the primary algorithm thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.AddOpenOrder(QuantConnect.Orders.Order,QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Register an already open Order
            </summary>
        </member>
    </members>
</doc>
